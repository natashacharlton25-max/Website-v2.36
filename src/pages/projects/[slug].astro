---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import FooterWithMask from '../../components/sections/FooterWithMask.astro';
import MasonryGrid from '../../components/ui/MasonryGrid.astro';

// Get all assets from content collection
const assetsEntries = await getCollection('assets');
const assetsMap = new Map<string, typeof assetsEntries[number]['data']>(
  assetsEntries.map(entry => [entry.slug, entry.data])
);

// Helper to get asset by slug
const getAssetBySlug = (slug: string) => assetsMap.get(slug);

// Helper to get asset card image path
const getAssetImagePath = (asset: any) => asset?.cardImage?.src || `/images/Assets/${asset?.slug}/card.png`;

// Export getStaticPaths for static site generation
export async function getStaticPaths() {
  const projectEntries = await getCollection('projects');
  return projectEntries.map(entry => ({
    params: { slug: entry.slug },
    props: { project: { slug: entry.slug, ...entry.data } }
  }));
}

const { project } = Astro.props;

// Fallback if project not found
if (!project) {
  return Astro.redirect('/projects');
}

// Seeded random number generator - produces consistent "random" results for same seed
function seededRandom(seed: number): () => number {
  return function() {
    seed = (seed * 1103515245 + 12345) & 0x7fffffff;
    return seed / 0x7fffffff;
  };
}

// Create seed from project slug - same slug always produces same order
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// Shuffle function using seeded random - consistent order for same seed
function shuffleArraySeeded<T>(array: T[], seed: number): T[] {
  const shuffled = [...array];
  const random = seededRandom(seed);
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Select accent color based on project slug (each project gets a consistent accent color)
const accentColors = ['AccentOne', 'AccentTwo', 'AccentThree', 'AccentFour', 'AccentFive'];
const slugHash = project.slug.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
const selectedAccent = accentColors[slugHash % accentColors.length];

// Monochrome color scheme generator - alternates shades to avoid same colors adjacent
// Using full token range (100-800) for maximum variety
const colorShades = [
  { bg: `var(--color-${selectedAccent}-100)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-300)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-200)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-400)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-500)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-600)`, text: 'white' },
  { bg: `var(--color-${selectedAccent}-700)`, text: 'white' },
  { bg: `var(--color-${selectedAccent}-800)`, text: 'white' },
];

let colorIndex = 0;
const getNextColor = () => {
  const color = colorShades[colorIndex % colorShades.length];
  colorIndex++;
  return color;
};

// Icon mapper function - matches tag names to appropriate icons (using Phosphor Duotone icons)
const getIconForTag = (tag: string): string => {
  const tagLower = tag.toLowerCase();

  // Mindfulness & Meditation
  if (tagLower.includes('mindful')) return 'ph:peace-duotone';
  if (tagLower.includes('meditation')) return 'ph:flower-lotus-duotone';
  if (tagLower.includes('breathing')) return 'ph:wind-duotone';

  // Wellbeing & Health
  if (tagLower.includes('wellbeing') || tagLower.includes('well-being')) return 'ph:heart-duotone';
  if (tagLower.includes('health')) return 'ph:heartbeat-duotone';
  if (tagLower.includes('wellness')) return 'ph:sparkle-duotone';

  // Self-Care & Care
  if (tagLower.includes('self-care') || tagLower.includes('selfcare')) return 'ph:hand-heart-duotone';
  if (tagLower.includes('care')) return 'ph:hands-praying-duotone';

  // Emotions
  if (tagLower.includes('emotion')) return 'ph:smiley-duotone';
  if (tagLower.includes('feeling')) return 'ph:heart-straight-duotone';
  if (tagLower.includes('calm')) return 'ph:moon-stars-duotone';
  if (tagLower.includes('stress')) return 'ph:brain-duotone';
  if (tagLower.includes('anxiety')) return 'ph:butterfly-duotone';

  // Activities
  if (tagLower.includes('sensory')) return 'ph:hand-palm-duotone';
  if (tagLower.includes('creative')) return 'ph:palette-duotone';
  if (tagLower.includes('movement')) return 'ph:person-simple-walk-duotone';
  if (tagLower.includes('nature')) return 'ph:leaf-duotone';
  if (tagLower.includes('music')) return 'ph:music-notes-duotone';

  // Default - use a variety of generic icons based on the tag name
  const genericIcons = [
    'ph:sparkle-duotone',
    'ph:star-duotone',
    'ph:circles-three-duotone',
    'ph:squares-four-duotone',
    'ph:flower-duotone',
    'ph:sun-duotone',
    'ph:placeholder-duotone',
    'ph:chats-circle-duotone',
    'ph:compass-duotone',
    'ph:lightbulb-duotone'
  ];

  // Use a simple hash to consistently select the same icon for the same tag
  let hash = 0;
  for (let i = 0; i < tag.length; i++) {
    hash = ((hash << 5) - hash) + tag.charCodeAt(i);
    hash = hash & hash;
  }

  return genericIcons[Math.abs(hash) % genericIcons.length];
};

// Masonry cards (everything else)
const summaryColor = getNextColor();
const actionColor1 = getNextColor();
const actionColor2 = getNextColor();
const info1Color = getNextColor();
const info2Color = getNextColor();
const info3Color = getNextColor();

// Icon mapper for benefits (matches benefit text to appropriate icons)
const getIconForBenefit = (benefit: string): string => {
  const lower = benefit.toLowerCase();
  if (lower.includes('emotion')) return 'ph:heart-duotone';
  if (lower.includes('confidence') || lower.includes('agency')) return 'ph:star-duotone';
  if (lower.includes('motor') || lower.includes('coordination')) return 'ph:hand-duotone';
  if (lower.includes('language') || lower.includes('narrative')) return 'ph:chat-circle-text-duotone';
  if (lower.includes('stress') || lower.includes('mood')) return 'ph:sun-duotone';
  if (lower.includes('creative') || lower.includes('expression')) return 'ph:palette-duotone';
  if (lower.includes('problem') || lower.includes('solving')) return 'ph:lightbulb-duotone';
  if (lower.includes('regulation')) return 'ph:scales-duotone';
  return 'ph:check-circle-duotone';
};

// Icon mapper for linked skills
const getIconForSkill = (skill: string): string => {
  const lower = skill.toLowerCase();
  if (lower.includes('language')) return 'ph:chat-circle-text-duotone';
  if (lower.includes('motor')) return 'ph:hand-duotone';
  if (lower.includes('emotion') || lower.includes('regulation')) return 'ph:heart-duotone';
  if (lower.includes('problem') || lower.includes('solving')) return 'ph:lightbulb-duotone';
  if (lower.includes('social')) return 'ph:users-duotone';
  if (lower.includes('cognitive') || lower.includes('thinking')) return 'ph:brain-duotone';
  if (lower.includes('sensory')) return 'ph:hand-palm-duotone';
  if (lower.includes('communication')) return 'ph:chats-duotone';
  return 'ph:puzzle-piece-duotone';
};

const masonryCards = [
  // Tag cards first
  ...project.tags.map((tag) => {
    const tagColor = getNextColor();
    return {
      type: 'tag' as const,
      title: tag,
      bgColor: tagColor.bg,
      textColor: tagColor.text,
      size: 'small' as const,
      icon: getIconForTag(tag)
    };
  }),

  // Auto-generated resource count spec
  (() => {
    const specColor = getNextColor();
    return {
      type: 'spec' as const,
      title: 'Resources',
      content: String(project.resourceSlugs.length),
      bgColor: specColor.bg,
      textColor: specColor.text,
      size: 'small' as const
    };
  })(),

  // Summary
  {
    type: 'summary' as const,
    content: project.description,
    bgColor: summaryColor.bg,
    textColor: summaryColor.text,
    size: 'large' as const
  },
  // Action buttons
  {
    type: 'text' as const,
    title: 'Project Package',
    content: 'Add all ' + project.resourceSlugs.length + ' resources from this project to your basket.',
    bgColor: actionColor1.bg,
    textColor: actionColor1.text,
    button: {
      text: 'Add Resources',
      link: '#add-all'
    },
    size: 'medium' as const
  },
  {
    type: 'text' as const,
    title: 'Resource Notes',
    content: 'Download guidance notes and professional information for all resources in this project.',
    bgColor: actionColor2.bg,
    textColor: actionColor2.text,
    button: {
      text: 'Add All Notes',
      link: '#add-notes'
    },
    size: 'medium' as const
  },
  // Info cards
  {
    type: 'text' as const,
    title: 'Who its for',
    content: project.whoItsFor,
    bgColor: info1Color.bg,
    textColor: info1Color.text,
    size: 'medium' as const
  },
  {
    type: 'text' as const,
    title: 'What it is',
    content: project.longDescription,
    bgColor: info2Color.bg,
    textColor: info2Color.text,
    size: 'medium' as const
  },

  // Evidence-based benefits as individual highlight cards
  ...(project.professional?.evidenceBasedBenefits || []).map((benefit) => {
    const benefitColor = getNextColor();
    return {
      type: 'highlight' as const,
      content: benefit,
      icon: getIconForBenefit(benefit),
      bgColor: benefitColor.bg,
      textColor: benefitColor.text,
      size: 'medium' as const
    };
  }),

  // Linked skills as small tag-style cards
  ...(project.professional?.linkedSkills || []).map((skill) => {
    const skillColor = getNextColor();
    return {
      type: 'tag' as const,
      title: skill,
      icon: getIconForSkill(skill),
      bgColor: skillColor.bg,
      textColor: skillColor.text,
      size: 'small' as const
    };
  }),
  // Asset/resource cards - pull from assets data
  ...project.resourceSlugs.map((slug, index) => {
    const asset = getAssetBySlug(slug);
    const resourceColor = getNextColor();

    // Use asset data if available, fallback to slug-based name
    const resourceName = asset?.name || slug.split('-').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    const resourceDescription = asset?.description || 'Free resource to download and use';

    // Map asset type to display type and icon
    const typeConfig: Record<string, { label: string; icon: string }> = {
      'worksheet': { label: 'Worksheet', icon: 'ph:note-pencil-duotone' },
      'workbook': { label: 'Workbook', icon: 'ph:book-duotone' },
      'guide': { label: 'Guide', icon: 'ph:book-open-duotone' },
      'toolkit': { label: 'Toolkit', icon: 'ph:toolbox-duotone' },
      'cards': { label: 'Cards', icon: 'ph:cards-duotone' },
      'poster': { label: 'Poster', icon: 'ph:image-duotone' },
      'activity': { label: 'Activity', icon: 'ph:game-controller-duotone' },
    };

    const resourceType = asset?.type ? typeConfig[asset.type]?.label || 'Resource' : 'Resource';
    const resourceIcon = asset?.type ? typeConfig[asset.type]?.icon || 'ph:file-duotone' : 'ph:file-duotone';

    // First 2 resources get image cards (if asset has image), rest are text-only
    if (index < 2 && asset) {
      return {
        type: 'mixed' as const,
        image: getAssetImagePath(asset),
        alt: resourceName,
        title: resourceName,
        content: resourceDescription,
        link: `/assets/${slug}`,
        bgColor: resourceColor.bg,
        textColor: resourceColor.text,
        badge: resourceType
      };
    } else {
      return {
        type: 'text' as const,
        title: resourceName,
        content: resourceDescription,
        link: `/assets/${slug}`,
        bgColor: resourceColor.bg,
        textColor: resourceColor.text,
        icon: resourceIcon,
        size: 'medium' as const
      };
    }
  }),
  // Specifications from frontmatter - label/value pairs
  ...(project.specifications || []).map((spec) => {
    const specColor = getNextColor();
    return {
      type: 'spec' as const,
      title: spec.label,
      content: spec.value,
      icon: spec.icon,
      bgColor: specColor.bg,
      textColor: specColor.text,
      size: 'small' as const
    };
  }),
  // Highlights from frontmatter - standalone callouts
  ...(project.highlights || []).map((highlight) => {
    const highlightColor = getNextColor();
    return {
      type: 'highlight' as const,
      content: highlight.text,
      icon: highlight.icon,
      bgColor: highlightColor.bg,
      textColor: highlightColor.text,
      size: 'medium' as const
    };
  })
];

// Randomize card order using seeded shuffle - consistent order for same project
const projectSeed = hashString(project.slug);
const shuffledMasonryCards = shuffleArraySeeded(masonryCards, projectSeed);
---

<BaseLayout
  title={`${project.title} | Projects | Walking with a Smile`}
  description={project.description}
  hideFooter={true}
>
  <!-- Hybrid Grid + Masonry Layout -->
  <section class="project-masonry-page bg-alt">
    <div class="container container-6xl">
      <!-- Title Section - Simple left-aligned -->
      <header class="project-header">
        <h1 class="project-title">{project.title}</h1>
        <p class="project-description">{project.description}</p>
      </header>

      <!-- Masonry Section (Everything Else) -->
      <MasonryGrid cards={shuffledMasonryCards} />
    </div>
  </section>

  <FooterWithMask
    backgroundImage="/Footer/Footer-Reveal.png"
  />
</BaseLayout>


<style>
  /* Project page - uses .bg-alt class for accessibility theme support */
  .project-masonry-page {
    padding: calc(80px + var(--space-3xl)) 0 var(--space-5xl);
    /* Background handled by .bg-alt class from utilities.css */
  }

  /* Project Header - Simple left-aligned */
  .project-header {
    margin-bottom: var(--space-4xl);
  }

  /* Page Title - uses global h1 settings */
  .project-title {
    font-family: var(--font-heading, 'Quicksand'), sans-serif;
    font-size: var(--text-5xl, 3rem);
    font-weight: var(--font-bold, 700);
    color: var(--color-Text-700);
    line-height: var(--leading-tight, 1.2);
    margin: 0 0 var(--space-md) 0;
    text-align: left;
  }

  /* Project Description / Subtext */
  .project-description {
    font-family: var(--font-body, 'Quicksand'), sans-serif;
    font-size: var(--text-lg, 1.125rem);
    font-weight: var(--font-normal, 400);
    color: var(--color-Text-600);
    line-height: var(--leading-relaxed, 1.6);
    margin: 0;
    max-width: 800px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .project-title {
      font-size: var(--text-4xl, 2.25rem);
    }

    .project-description {
      font-size: var(--text-base, 1rem);
    }
  }

  @media (max-width: 640px) {
    .project-masonry-page {
      padding: calc(80px + var(--space-2xl)) 0 var(--space-4xl);
    }

    .project-header {
      margin-bottom: var(--space-3xl);
    }

    .project-title {
      font-size: var(--text-3xl, 1.875rem);
    }
  }

  /* =========================================================
     ACCESSIBILITY THEME OVERRIDES - Project Page
     ========================================================= */

  /* Dark mode */
  :global(body.a11y-theme-dark) .project-title {
    color: var(--a11y-dark-text) !important;
  }

  :global(body.a11y-theme-dark) .project-description {
    color: var(--a11y-dark-text) !important;
  }

  /* High contrast */
  :global(body.a11y-theme-high-contrast) .project-title {
    color: var(--a11y-hc-text, #ffffff) !important;
  }

  :global(body.a11y-theme-high-contrast) .project-description {
    color: var(--a11y-hc-text, #ffffff) !important;
  }

  /* Cream mode */
  :global(body.a11y-theme-cream) .project-title {
    color: var(--a11y-cream-text, #4a3f2f) !important;
  }

  :global(body.a11y-theme-cream) .project-description {
    color: #5d4f3a !important;
  }

  /* Monochrome */
  :global(body.a11y-theme-monochrome) .project-title,
  :global(body.a11y-cvd-monochrome) .project-title {
    color: #1a1a1a !important;
  }

  :global(body.a11y-theme-monochrome) .project-description,
  :global(body.a11y-cvd-monochrome) .project-description {
    color: #4a4a4a !important;
  }
</style>

