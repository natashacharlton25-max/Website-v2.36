---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import FooterWithMask from '../../components/Global/FooterWithMask.astro';
import MasonryGrid from '../../components/ui/MasonryGrid.astro';
import { getIconForTag, getIconForBenefit, getIconForSkill, getIconForAssetType } from '../../utils/iconMapper';

// Helper to get folder slug from entry.id (handles index.md suffix and path separators)
const getSlugFromId = (id: string) => {
  // Remove /index.md or \index.md suffix, then get folder name
  const normalized = id.replace(/[\\/]index\.md$/, '');
  return normalized.split(/[\\/]/).pop() || id;
};

// Get all assets from content collection
const assetsEntries = await getCollection('assets');
const assetsMap = new Map<string, typeof assetsEntries[number]['data']>(
  assetsEntries.map(entry => [getSlugFromId(entry.id), entry.data])
);

// Get all insights from content collection
const insightsEntries = await getCollection('insights');
const insightsMap = new Map<string, typeof insightsEntries[number]['data']>(
  insightsEntries.map(entry => [getSlugFromId(entry.id), entry.data])
);

// Get all presentations from content collection
const presentationsEntries = await getCollection('presentations');
const presentationsMap = new Map<string, typeof presentationsEntries[number]['data']>(
  presentationsEntries.map(entry => [getSlugFromId(entry.id), entry.data])
);

// Helper to get asset by slug
const getAssetBySlug = (slug: string) => assetsMap.get(slug);

// Helper to get insight by slug
const getInsightBySlug = (slug: string) => insightsMap.get(slug);

// Helper to get presentation by slug
const getPresentationBySlug = (slug: string) => presentationsMap.get(slug);

// Helper to get asset card image path
const getAssetImagePath = (asset: any) => asset?.cardImage?.src || `/images/Assets/${asset?.slug}/card.png`;

// Helper to get insight card image path
const getInsightImagePath = (insight: any) => insight?.cardImage?.src || null;

// Helper to get presentation card image path
const getPresentationImagePath = (presentation: any) => presentation?.cardImage?.src || null;

// Export getStaticPaths for static site generation
export async function getStaticPaths() {
  // Helper to get folder slug from entry.id (handles index.md suffix and path separators)
  const getSlug = (id: string) => {
    const normalized = id.replace(/[\\/]index\.md$/, '');
    return normalized.split(/[\\/]/).pop() || id;
  };

  const projectEntries = await getCollection('projects');
  return projectEntries.map(entry => {
    const slug = getSlug(entry.id);
    return {
      params: { slug },
      props: { project: { slug, ...entry.data } }
    };
  });
}

const { project } = Astro.props;

// Fallback if project not found
if (!project) {
  return Astro.redirect('/projects');
}

// Seeded random number generator - produces consistent "random" results for same seed
function seededRandom(seed: number): () => number {
  return function() {
    seed = (seed * 1103515245 + 12345) & 0x7fffffff;
    return seed / 0x7fffffff;
  };
}

// Create seed from project slug - same slug always produces same order
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash);
}

// Shuffle function using seeded random - consistent order for same seed
function shuffleArraySeeded<T>(array: T[], seed: number): T[] {
  const shuffled = [...array];
  const random = seededRandom(seed);
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Select accent color based on project slug (each project gets a consistent accent color)
const accentColors = ['AccentOne', 'AccentTwo', 'AccentThree', 'AccentFour', 'AccentFive'];
const slugHash = project.slug.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
const selectedAccent = accentColors[slugHash % accentColors.length];

// Monochrome color scheme generator - alternates shades to avoid same colors adjacent
// Using full token range (100-800) for maximum variety
const colorShades = [
  { bg: `var(--color-${selectedAccent}-100)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-300)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-200)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-400)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-500)`, text: 'var(--color-Text-700)' },
  { bg: `var(--color-${selectedAccent}-600)`, text: 'white' },
  { bg: `var(--color-${selectedAccent}-700)`, text: 'white' },
  { bg: `var(--color-${selectedAccent}-800)`, text: 'white' },
];

let colorIndex = 0;
const getNextColor = () => {
  const color = colorShades[colorIndex % colorShades.length];
  colorIndex++;
  return color;
};

// Masonry cards (everything else)
const summaryColor = getNextColor();
const actionColor1 = getNextColor();
const actionColor2 = getNextColor();
const info1Color = getNextColor();
const info2Color = getNextColor();
const info3Color = getNextColor();

const masonryCards = [
  // Tag cards first
  ...project.tags.map((tag) => {
    const tagColor = getNextColor();
    return {
      type: 'tag' as const,
      title: tag,
      bgColor: tagColor.bg,
      textColor: tagColor.text,
      size: 'small' as const,
      icon: getIconForTag(tag)
    };
  }),

  // Auto-generated resource count spec
  (() => {
    const specColor = getNextColor();
    return {
      type: 'spec' as const,
      title: 'Resources',
      content: String(project.resourceSlugs.length),
      bgColor: specColor.bg,
      textColor: specColor.text,
      size: 'small' as const
    };
  })(),

  // Summary
  {
    type: 'summary' as const,
    content: project.description,
    bgColor: summaryColor.bg,
    textColor: summaryColor.text,
    size: 'large' as const
  },
  // Action buttons
  {
    type: 'text' as const,
    title: 'Project Package',
    content: 'Add all ' + project.resourceSlugs.length + ' resources from this project to your basket.',
    bgColor: actionColor1.bg,
    textColor: actionColor1.text,
    button: {
      text: 'Add Resources',
      link: '#add-all'
    },
    size: 'medium' as const
  },
  {
    type: 'text' as const,
    title: 'Resource Notes',
    content: 'Download guidance notes and professional information for all resources in this project.',
    bgColor: actionColor2.bg,
    textColor: actionColor2.text,
    button: {
      text: 'Add All Notes',
      link: '#add-notes'
    },
    size: 'medium' as const
  },
  // Info cards
  {
    type: 'text' as const,
    title: 'Who its for',
    content: project.whoItsFor,
    bgColor: info1Color.bg,
    textColor: info1Color.text,
    size: 'medium' as const
  },
  {
    type: 'text' as const,
    title: 'What it is',
    content: project.longDescription,
    bgColor: info2Color.bg,
    textColor: info2Color.text,
    size: 'medium' as const
  },

  // Evidence-based benefits as individual highlight cards
  ...(project.professional?.evidenceBasedBenefits || []).map((benefit) => {
    const benefitColor = getNextColor();
    return {
      type: 'highlight' as const,
      content: benefit,
      icon: getIconForBenefit(benefit),
      bgColor: benefitColor.bg,
      textColor: benefitColor.text,
      size: 'medium' as const
    };
  }),

  // Linked skills as small tag-style cards
  ...(project.professional?.linkedSkills || []).map((skill) => {
    const skillColor = getNextColor();
    return {
      type: 'tag' as const,
      title: skill,
      icon: getIconForSkill(skill),
      bgColor: skillColor.bg,
      textColor: skillColor.text,
      size: 'small' as const
    };
  }),
  // Asset/resource cards - pull from assets data
  ...project.resourceSlugs.map((slug, index) => {
    const asset = getAssetBySlug(slug);
    const resourceColor = getNextColor();

    // Use asset data if available, fallback to slug-based name
    const resourceName = asset?.name || slug.split('-').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    const resourceDescription = asset?.description || 'Free resource to download and use';

    // Map asset type to display type and icon
    const typeLabels: Record<string, string> = {
      'worksheet': 'Worksheet',
      'workbook': 'Workbook',
      'guide': 'Guide',
      'toolkit': 'Toolkit',
      'cards': 'Cards',
      'poster': 'Poster',
      'activity': 'Activity',
    };

    const resourceType = asset?.type ? typeLabels[asset.type] || 'Resource' : 'Resource';
    const resourceIcon = asset?.type ? getIconForAssetType(asset.type) : 'objects/file-fill';

    // First 2 resources get image cards (if asset has image), rest are text-only
    if (index < 2 && asset) {
      return {
        type: 'mixed' as const,
        image: getAssetImagePath(asset),
        alt: resourceName,
        title: resourceName,
        content: resourceDescription,
        link: `/assets/${slug}`,
        bgColor: resourceColor.bg,
        textColor: resourceColor.text,
        badge: resourceType
      };
    } else {
      return {
        type: 'text' as const,
        title: resourceName,
        content: resourceDescription,
        link: `/assets/${slug}`,
        bgColor: resourceColor.bg,
        textColor: resourceColor.text,
        icon: resourceIcon,
        size: 'medium' as const
      };
    }
  }),
  // Insight cards - pull from insights data (differentiated with 'Article' badge and article icon)
  ...(project.insightSlugs || []).map((slug, index) => {
    const insight = getInsightBySlug(slug);
    const insightColor = getNextColor();

    // Use insight data if available, fallback to slug-based name
    const insightTitle = insight?.title || slug.split('-').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    const insightDescription = insight?.description || 'Read this article';
    const insightCategory = insight?.category || 'Article';

    // First insight gets image card, rest are text-only
    if (index < 1 && insight) {
      return {
        type: 'mixed' as const,
        image: getInsightImagePath(insight),
        alt: insightTitle,
        title: insightTitle,
        content: insightDescription,
        link: `/insights/${slug}`,
        bgColor: insightColor.bg,
        textColor: insightColor.text,
        badge: insightCategory
      };
    } else {
      return {
        type: 'text' as const,
        title: insightTitle,
        content: insightDescription,
        link: `/insights/${slug}`,
        bgColor: insightColor.bg,
        textColor: insightColor.text,
        icon: 'objects/article-fill',
        size: 'medium' as const
      };
    }
  }),
  // Presentation cards - pull from presentations data (differentiated with 'Presentation' badge and slideshow icon)
  ...(project.presentationSlugs || []).map((slug, index) => {
    const presentation = getPresentationBySlug(slug);
    const presentationColor = getNextColor();

    // Use presentation data if available, fallback to slug-based name
    const presentationTitle = presentation?.title || slug.split('-').map(word =>
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    const presentationDescription = presentation?.description || 'View this presentation';
    const presentationCategory = presentation?.category || 'Presentation';

    // First presentation gets image card, rest are text-only
    if (index < 1 && presentation) {
      return {
        type: 'mixed' as const,
        image: getPresentationImagePath(presentation),
        alt: presentationTitle,
        title: presentationTitle,
        content: presentationDescription,
        link: `/presentations/${slug}`,
        bgColor: presentationColor.bg,
        textColor: presentationColor.text,
        badge: presentationCategory
      };
    } else {
      return {
        type: 'text' as const,
        title: presentationTitle,
        content: presentationDescription,
        link: `/presentations/${slug}`,
        bgColor: presentationColor.bg,
        textColor: presentationColor.text,
        icon: 'objects/presentation-chart-fill',
        size: 'medium' as const
      };
    }
  }),
  // Specifications from frontmatter - label/value pairs
  ...(project.specifications || []).map((spec) => {
    const specColor = getNextColor();
    return {
      type: 'spec' as const,
      title: spec.label,
      content: spec.value,
      icon: spec.icon,
      bgColor: specColor.bg,
      textColor: specColor.text,
      size: 'small' as const
    };
  }),
  // Highlights from frontmatter - standalone callouts
  ...(project.highlights || []).map((highlight) => {
    const highlightColor = getNextColor();
    return {
      type: 'highlight' as const,
      content: highlight.text,
      icon: highlight.icon,
      bgColor: highlightColor.bg,
      textColor: highlightColor.text,
      size: 'medium' as const
    };
  })
];

// Randomize card order using seeded shuffle - consistent order for same project
const projectSeed = hashString(project.slug);
const shuffledMasonryCards = shuffleArraySeeded(masonryCards, projectSeed);
---

<BaseLayout
  title={`${project.title} | Projects | Walking with a Smile`}
  description={project.description}
  hideFooter={true}
>
  <!-- Hybrid Grid + Masonry Layout -->
  <section class="project-masonry-page bg-alt">
    <div class="container container-6xl">
      <!-- Title Section - Simple left-aligned -->
      <header class="project-header">
        <h1 class="project-title">{project.title}</h1>
        <p class="project-description">{project.description}</p>
      </header>

      <!-- Masonry Section (Everything Else) -->
      <MasonryGrid cards={shuffledMasonryCards} />
    </div>
  </section>

  <FooterWithMask
    backgroundImage="/Footer/Footer-Reveal.png"
  />
</BaseLayout>


<style>
  /* Project page - uses .bg-alt class for accessibility theme support */
  .project-masonry-page {
    padding: calc(80px + var(--space-3xl)) 0 var(--space-5xl);
    /* Background handled by .bg-alt class from utilities.css */
  }

  /* Project Header - Simple left-aligned */
  .project-header {
    margin-bottom: var(--space-4xl);
  }

  /* Page Title - uses global h1 settings */
  .project-title {
    font-family: var(--font-heading, 'Quicksand'), sans-serif;
    font-size: var(--text-5xl, 3rem);
    font-weight: var(--font-bold, 700);
    color: var(--color-Text-700);
    line-height: var(--leading-tight, 1.2);
    margin: 0 0 var(--space-md) 0;
    text-align: left;
  }

  /* Project Description / Subtext */
  .project-description {
    font-family: var(--font-body, 'Quicksand'), sans-serif;
    font-size: var(--text-lg, 1.125rem);
    font-weight: var(--font-normal, 400);
    color: var(--color-Text-600);
    line-height: var(--leading-relaxed, 1.6);
    margin: 0;
    max-width: 800px;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .project-title {
      font-size: var(--text-4xl, 2.25rem);
    }

    .project-description {
      font-size: var(--text-base, 1rem);
    }
  }

  @media (max-width: 640px) {
    .project-masonry-page {
      padding: calc(80px + var(--space-2xl)) 0 var(--space-4xl);
    }

    .project-header {
      margin-bottom: var(--space-3xl);
    }

    .project-title {
      font-size: var(--text-3xl, 1.875rem);
    }
  }

  /* =========================================================
     ACCESSIBILITY THEME OVERRIDES - Project Page
     ========================================================= */

  /* Dark mode */
  :global(body.a11y-theme-dark) .project-title {
    color: var(--a11y-dark-text) !important;
  }

  :global(body.a11y-theme-dark) .project-description {
    color: var(--a11y-dark-text) !important;
  }

  /* High contrast */
  :global(body.a11y-theme-high-contrast) .project-title {
    color: var(--a11y-hc-text, #ffffff) !important;
  }

  :global(body.a11y-theme-high-contrast) .project-description {
    color: var(--a11y-hc-text, #ffffff) !important;
  }

  /* Cream mode */
  :global(body.a11y-theme-cream) .project-title {
    color: var(--a11y-cream-text, #4a3f2f) !important;
  }

  :global(body.a11y-theme-cream) .project-description {
    color: #5d4f3a !important;
  }

  /* Monochrome */
  :global(body.a11y-theme-monochrome) .project-title,
  :global(body.a11y-cvd-monochrome) .project-title {
    color: #1a1a1a !important;
  }

  :global(body.a11y-theme-monochrome) .project-description,
  :global(body.a11y-cvd-monochrome) .project-description {
    color: #4a4a4a !important;
  }
</style>

