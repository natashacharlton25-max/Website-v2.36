---
import type { ReaderSection, ReaderHeroSection, ReaderEndSection } from '../../lib/config/reader-types';
import '../../styles/components/presentation/Reader.css';

interface Props {
  sections: ReaderSection[];
  heroSection?: ReaderHeroSection;
  endSection?: ReaderEndSection;
}

const { sections, heroSection, endSection } = Astro.props;
---

{/* Reader Wrapper - TRACKS all sections including optional hero/end */}
<section class="reader-wrapper" data-reader-wrapper>
  <div class="reader-container" data-reader-container>
    {/* Optional Hero Section - TRACKED as first section */}
    {heroSection && (
      <div
        class="reader-section reader-section--hero"
        data-reader-section
        data-section-id="hero"
        data-section-index="0"
        id="section-hero"
      >
        <div class="reader-hero-inner">
          <div class="hero-image-container">
            {heroSection.image && <img src={heroSection.image} alt={heroSection.title} />}
          </div>
          <div class="hero-overlay">
            <div class="container container-6xl">
              {(heroSection.category || heroSection.date) && (
                <div class="hero-meta">
                  {heroSection.category && (
                    <span class="hero-category">{heroSection.category}</span>
                  )}
                  {heroSection.date && <span class="hero-date">{heroSection.date}</span>}
                </div>
              )}
              <h1 class="hero-title">{heroSection.title}</h1>
              {heroSection.description && (
                <p class="hero-description">{heroSection.description}</p>
              )}
            </div>
          </div>
        </div>
      </div>
    )}

    {/* Main Content Sections - TRACKED */}
    {sections.map((section, index) => {
      const layout = section.layout || 'text-only';
      const alignment = section.alignment || 'center';
      const imagePosition = section.imagePosition || 'right';
      const sectionIndex = heroSection ? index + 1 : index;

      return (
        <div
          class={`reader-section reader-section--${layout}`}
          data-reader-section
          data-section-id={section.id}
          data-section-index={sectionIndex}
          id={`section-${section.id}`}
        >
          {/* Text-only layout */}
          {layout === 'text-only' && (
            <div class={`section-content section-content--${alignment}`}>
              <h2 class="section-title">{section.title}</h2>
              <div class="section-body" set:html={section.body} />
            </div>
          )}

          {/* Image + Text layout */}
          {layout === 'image-text' && (
            <div class={`section-grid section-grid--${imagePosition}`}>
              <div class="section-text">
                <h2 class="section-title">{section.title}</h2>
                <div class="section-body" set:html={section.body} />
              </div>
              <div class="section-image">
                <img
                  src={section.image}
                  alt={section.title}
                  loading="lazy"
                />
              </div>
            </div>
          )}

          {/* Full-width image layout */}
          {layout === 'full-width-image' && (
            <div class="section-fullwidth">
              <div class="section-image-bg">
                <img
                  src={section.image}
                  alt={section.title}
                  loading="lazy"
                />
              </div>
              <div class="section-card-wrapper">
                <div class="section-glass-card">
                  <h2 class="section-title">{section.title}</h2>
                  <div class="section-body" set:html={section.body} />
                </div>
              </div>
            </div>
          )}
        </div>
      );
    })}

    {/* Optional End Section - TRACKED as last section */}
    {endSection && (
      <div
        class="reader-section reader-section--end"
        data-reader-section
        data-section-id="end"
        data-section-index={(heroSection ? 1 : 0) + sections.length}
        id="section-end"
      >
        <div class="reader-end-inner" set:html={endSection.html} />
      </div>
    )}
  </div>
</section>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  function initReader() {
    const wrapper = document.querySelector('[data-reader-wrapper]') as HTMLElement;
    if (!wrapper) return;

    // Skip GSAP animations in plain mode and force reset inline styles
    if (document.body.classList.contains('plain')) {
      // Kill any existing ScrollTriggers on this wrapper
      ScrollTrigger.getAll().forEach(st => st.kill());

      // Reset wrapper inline styles
      wrapper.style.minHeight = '0';
      wrapper.style.height = 'auto';
      wrapper.style.position = 'static';

      // Reset container inline styles (GSAP sets these)
      const container = wrapper.querySelector('[data-reader-container]') as HTMLElement;
      if (container) {
        container.style.cssText = '';
      }

      // Reset all section inline styles
      const sections = wrapper.querySelectorAll('[data-reader-section]') as NodeListOf<HTMLElement>;
      sections.forEach(section => {
        section.style.cssText = '';
      });

      // Remove pin-spacer if it exists
      const pinSpacer = wrapper.closest('.pin-spacer');
      if (pinSpacer && pinSpacer.parentNode) {
        pinSpacer.parentNode.insertBefore(wrapper, pinSpacer);
        pinSpacer.remove();
      }
      return;
    }

    const container = wrapper.querySelector('[data-reader-container]') as HTMLElement;
    const sections = Array.from(
      wrapper.querySelectorAll('[data-reader-section]')
    ) as HTMLElement[];

    if (sections.length === 0) return;

    // Set CSS variable for dynamic height calculation
    wrapper.style.setProperty('--section-count', sections.length.toString());

    // Set initial states
    sections.forEach((section, index) => {
      if (index === 0) {
        gsap.set(section, { opacity: 1 });
      } else {
        gsap.set(section, { opacity: 0 });
      }
    });

    // Create master timeline with pin AND progress tracking
    const masterTimeline = gsap.timeline({
      scrollTrigger: {
        trigger: wrapper,
        start: 'top top',
        end: `+=${sections.length * window.innerHeight * 1.5}`,
        scrub: 1.5,
        pin: container,
        pinSpacing: true,
        anticipatePin: 1,
        markers: false,
        onUpdate: (self) => {
          // Track progress from the SAME ScrollTrigger as the animations
          const progress = self.progress;
          // Round to nearest section (changes at 50% through transition)
          const currentIndex = Math.round(progress * (sections.length - 1));
          const clampedIndex = Math.max(0, Math.min(currentIndex, sections.length - 1));
          const currentSection = sections[clampedIndex];

          // Dispatch progress event for ReaderNav
          if (currentSection) {
            const sectionId = currentSection.dataset.sectionId;

            window.dispatchEvent(
              new CustomEvent('reader:progress', {
                detail: {
                  index: clampedIndex,
                  id: sectionId || '',
                  progress: progress,
                  totalProgress: progress * 100,
                },
              })
            );
          }

          // Update window reference
          (window as any).readerCurrentSection = {
            index: clampedIndex,
            id: currentSection?.dataset.sectionId || '',
            progress: progress,
            totalProgress: progress * 100,
          };
        },
      },
    });

    // Animation sequence: staggered fades with NO overlap
    // Fade-out: 0.3s, Gap: 0.05s, Fade-in: 0.5s
    sections.forEach((section, index) => {
      if (index === sections.length - 1) return; // Last section stays visible

      const nextSection = sections[index + 1];
      const sectionDuration = 1; // Total duration for this section's transition

      // Fade out current section (fast: 0.3s)
      masterTimeline.to(
        section,
        {
          opacity: 0,
          duration: 0.3,
          ease: 'power2.inOut',
        },
        index * sectionDuration
      );

      // Fade in next section (slower: 0.5s, starts after fade-out + gap)
      masterTimeline.fromTo(
        nextSection,
        { opacity: 0 },
        {
          opacity: 1,
          duration: 0.5,
          ease: 'power2.inOut',
        },
        index * sectionDuration + 0.35 // 0.35 = 0.3 (fade-out) + 0.05 (gap)
      );
    });

    // Expose current section to window for debugging/external access
    (window as any).readerCurrentSection = {
      index: 0,
      id: sections[0]?.dataset.sectionId,
      progress: 0,
      totalProgress: 0,
    };
  }

  // Cleanup function
  function cleanupReader() {
    ScrollTrigger.getAll().forEach((trigger) => {
      const triggerEl = trigger.vars.trigger;
      if (triggerEl instanceof Element && triggerEl.classList?.contains('reader-wrapper')) {
        trigger.kill();
      }
    });
  }

  // Initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initReader);
  } else {
    initReader();
  }

  // Support Astro page transitions
  document.addEventListener('astro:page-load', initReader);
  document.addEventListener('astro:before-preparation', cleanupReader);
</script>
