---
import type { ReaderNavSection } from '../../config/reader-types';
import './ReaderNav.css';

interface Props {
  sections: ReaderNavSection[];
  position?:
    | 'top-left'
    | 'top-center'
    | 'top-right'
    | 'middle-left'
    | 'middle-center'
    | 'middle-right'
    | 'bottom-left'
    | 'bottom-center'
    | 'bottom-right';
  variant?: 'minimal' | 'detailed';
  background?: 'dark' | 'light' | 'glass';
  foreground?: 'light' | 'dark';
}

const {
  sections,
  position = 'top-left',
  variant = 'detailed',
  background = 'glass',
  foreground = 'light',
} = Astro.props;
---

<nav
  class={`reader-nav reader-nav--${position} reader-nav--${variant} reader-nav--bg-${background} reader-nav--fg-${foreground}`}
  data-reader-nav
  aria-label="Reader navigation"
>
  <div class="reader-nav-container">
    {/* Prev/Next Navigation Buttons */}
    <div class="nav-arrows">
      <button
        class="nav-arrow nav-arrow--prev"
        data-nav-prev
        aria-label="Previous section"
        disabled
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
        <span>Prev</span>
      </button>
      <button
        class="nav-arrow nav-arrow--next"
        data-nav-next
        aria-label="Next section"
      >
        <span>Next</span>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="9 6 15 12 9 18"></polyline>
        </svg>
      </button>
    </div>

    {/* Top row: Circle + Current Section */}
    <div class="nav-header">
      <!-- Progress Circle -->
      <div class="progress-circle-wrapper" data-progress-wrapper>
        <svg
          class="progress-circle"
          width="60"
          height="60"
          viewBox="0 0 60 60"
          aria-hidden="true"
        >
          <!-- Background circle -->
          <circle
            cx="30"
            cy="30"
            r="27"
            class="progress-bg"
            stroke="var(--color-Neutral-300)"
            stroke-width="3"
            fill="none"
          />
          <!-- Progress circle -->
          <circle
            cx="30"
            cy="30"
            r="27"
            class="progress-bar"
            stroke="var(--color-Primary-500)"
            stroke-width="3"
            fill="none"
            stroke-linecap="round"
            data-progress-circle
          />
        </svg>

        <!-- Percentage display -->
        <div class="progress-percentage" aria-live="polite" aria-atomic="true">
          <span data-percentage>0</span>%
        </div>
      </div>

      {
        variant === 'detailed' && (
          <div class="reader-nav-content">
            <!-- Current section title with dropdown toggle -->
            <button
              class="nav-toggle"
              data-nav-toggle
              aria-expanded="false"
              aria-controls="section-dropdown"
              aria-label="Toggle section menu"
            >
              <span class="current-section-title" data-current-title>
                {sections[0]?.title || 'Introduction'}
              </span>
              <svg
                class="toggle-icon"
                width="16"
                height="16"
                viewBox="0 0 16 16"
                fill="none"
                aria-hidden="true"
              >
                <path
                  d="M4 6L8 10L12 6"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          </div>
        )
      }
    </div>

    {/* Expandable dropdown list */}
    {
      variant === 'detailed' && (
        <div
          class="section-dropdown"
          id="section-dropdown"
          data-dropdown
          role="menu"
        >
          <ul class="section-list">
            {sections.map((section, index) => (
              <li role="none">
                <button
                  class="section-item"
                  data-section-nav={section.id}
                  data-section-index={index}
                  role="menuitem"
                  aria-label={`Navigate to ${section.title}`}
                >
                  <span class="section-number">
                    {String(index + 1).padStart(2, '0')}
                  </span>
                  <span class="section-name">{section.title}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>
      )
    }
  </div>
</nav>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  class ReaderNav {
    nav: HTMLElement;
    progressCircle: SVGCircleElement;
    progressText: HTMLElement;
    currentTitleEl: HTMLElement | null;
    toggleBtn: HTMLElement | null;
    dropdown: HTMLElement | null;
    sectionButtons: NodeListOf<HTMLElement>;
    prevBtn: HTMLButtonElement | null;
    nextBtn: HTMLButtonElement | null;
    isOpen = false;
    circumference = 169.64; // 2 * Ï€ * 27
    sections: Array<{ id: string; title: string; element: HTMLElement | null }> = [];
    currentIndex = 0;

    constructor(nav: HTMLElement) {
      this.nav = nav;
      this.progressCircle = nav.querySelector('[data-progress-circle]') as SVGCircleElement;
      this.progressText = nav.querySelector('[data-percentage]') as HTMLElement;
      this.currentTitleEl = nav.querySelector('[data-current-title]');
      this.toggleBtn = nav.querySelector('[data-nav-toggle]');
      this.dropdown = nav.querySelector('[data-dropdown]');
      this.sectionButtons = nav.querySelectorAll('[data-section-nav]');
      this.prevBtn = nav.querySelector('[data-nav-prev]');
      this.nextBtn = nav.querySelector('[data-nav-next]');

      this.init();
    }

    init(): void {
      // Build sections array
      this.sectionButtons.forEach((btn) => {
        const id = btn.dataset.sectionNav;
        const title = btn.querySelector('.section-name')?.textContent || '';
        const element = id ? document.getElementById(`section-${id}`) : null;

        if (id) {
          this.sections.push({ id, title, element });
        }
      });

      // Set initial progress
      this.updateProgress(0);

      // Initialize prev/next button states
      this.updateNavButtonStates();

      // Setup glide in/out animation
      this.setupGlideAnimation();

      // Toggle dropdown
      this.toggleBtn?.addEventListener('click', () => this.toggleDropdown());

      // Section navigation
      this.sectionButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const sectionId = btn.dataset.sectionNav;
          if (sectionId) {
            this.navigateToSection(sectionId);
          }
        });
      });

      // Prev/Next button navigation
      this.prevBtn?.addEventListener('click', () => this.goToPrevSection());
      this.nextBtn?.addEventListener('click', () => this.goToNextSection());

      // Listen to reader progress events
      window.addEventListener('reader:progress', ((e: CustomEvent) => {
        const { index, totalProgress } = e.detail;

        // Display RAW progress (0-100%)
        this.updateProgress(totalProgress);

        // Use the index directly from Reader (no offset)
        this.updateActiveSection(index);
      }) as EventListener);

      // Close dropdown on outside click
      document.addEventListener('click', (e) => {
        if (!this.nav.contains(e.target as Node)) {
          this.closeDropdown();
        }
      });

      // Keyboard navigation
      this.nav.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeDropdown();
        }
      });
    }

    updateProgress(percentage: number): void {
      const offset = this.circumference - (percentage / 100) * this.circumference;
      this.progressCircle.style.strokeDashoffset = offset.toString();
      this.progressText.textContent = Math.round(percentage).toString();
    }

    updateActiveSection(index: number): void {
      this.currentIndex = index;
      const section = this.sections[index];

      if (section && this.currentTitleEl) {
        this.currentTitleEl.textContent = section.title;
      }

      // Update active states in dropdown
      this.sectionButtons.forEach((btn, i) => {
        if (i === index) {
          btn.classList.add('is-active');
        } else {
          btn.classList.remove('is-active');
        }
      });

      // Update prev/next button states
      this.updateNavButtonStates();
    }

    updateNavButtonStates(): void {
      const isFirst = this.currentIndex === 0;
      const isLast = this.currentIndex === this.sections.length - 1;

      if (this.prevBtn) {
        this.prevBtn.disabled = isFirst;
      }
      if (this.nextBtn) {
        this.nextBtn.disabled = isLast;
      }
    }

    goToPrevSection(): void {
      if (this.currentIndex > 0) {
        const prevSection = this.sections[this.currentIndex - 1];
        if (prevSection) {
          this.navigateToSection(prevSection.id);
        }
      }
    }

    goToNextSection(): void {
      if (this.currentIndex < this.sections.length - 1) {
        const nextSection = this.sections[this.currentIndex + 1];
        if (nextSection) {
          this.navigateToSection(nextSection.id);
        }
      }
    }

    navigateToSection(sectionId: string): void {
      // Find the section index
      const sectionIndex = this.sections.findIndex(s => s.id === sectionId);

      if (sectionIndex === -1) {
        this.closeDropdown();
        return;
      }

      // Find the Reader wrapper
      const readerWrapper = document.querySelector('[data-reader-wrapper]') as HTMLElement;
      if (!readerWrapper) {
        this.closeDropdown();
        return;
      }

      // Calculate scroll position to activate this section
      // Reader uses Math.round(progress * (sections.length - 1)) to determine active section
      // So to activate section i, we need progress = i / (sections.length - 1)
      const totalSections = this.sections.length;
      const targetProgress = totalSections > 1 ? sectionIndex / (totalSections - 1) : 0;

      // Total scroll distance for the Reader
      const totalScrollHeight = totalSections * window.innerHeight * 1.5;

      // Calculate scroll position
      const wrapperTop = readerWrapper.offsetTop;
      const targetScrollPosition = wrapperTop + (targetProgress * totalScrollHeight);

      // Smooth scroll to calculated position
      window.scrollTo({
        top: targetScrollPosition,
        behavior: 'smooth'
      });

      this.closeDropdown();
    }

    toggleDropdown(): void {
      if (this.isOpen) {
        this.closeDropdown();
      } else {
        this.openDropdown();
      }
    }

    openDropdown(): void {
      this.isOpen = true;
      this.dropdown?.classList.add('is-open');
      this.toggleBtn?.setAttribute('aria-expanded', 'true');

      // Focus first menu item
      const firstItem = this.dropdown?.querySelector('.section-item') as HTMLElement;
      firstItem?.focus();
    }

    closeDropdown(): void {
      this.isOpen = false;
      this.dropdown?.classList.remove('is-open');
      this.toggleBtn?.setAttribute('aria-expanded', 'false');
    }

    setupGlideAnimation(): void {
      // Determine glide direction based on position class
      const position = Array.from(this.nav.classList)
        .find((cls) => cls.startsWith('reader-nav--'))
        ?.replace('reader-nav--', '');

      // Set initial hidden state based on position (horizontal only)
      let initialX = 0;
      let initialY = 0; // No vertical glide

      if (position?.includes('left')) {
        initialX = -100; // Glide in from left
      } else if (position?.includes('right')) {
        initialX = 100; // Glide in from right
      }
      // Center positions don't glide horizontally

      // Animate the container to avoid transform conflicts with fixed positioning
      const container = this.nav.querySelector('.reader-nav-container') as HTMLElement;
      if (!container) return;

      // Set initial hidden state immediately
      gsap.set(container, {
        opacity: 0,
        x: initialX,
        y: initialY,
      });

      // Wait for Reader wrapper to be in DOM
      const waitForWrapper = () => {
        const readerWrapper = document.querySelector('[data-reader-wrapper]');
        if (!readerWrapper) {
          setTimeout(waitForWrapper, 100);
          return;
        }

        // Create ScrollTrigger for glide in/out
        const glideScrollTrigger = ScrollTrigger.create({
          trigger: readerWrapper,
          start: 'top 80%',
          end: 'bottom 20%',
          markers: false,
          onEnter: () => {
            gsap.to(container, {
              opacity: 1,
              x: 0,
              y: 0,
              duration: 0.8,
              ease: 'power3.out',
            });
          },
          onLeave: () => {
            gsap.to(container, {
              opacity: 0,
              x: initialX,
              y: initialY,
              duration: 0.6,
              ease: 'power2.in',
            });
          },
          onEnterBack: () => {
            gsap.to(container, {
              opacity: 1,
              x: 0,
              y: 0,
              duration: 0.8,
              ease: 'power3.out',
            });
          },
          onLeaveBack: () => {
            gsap.to(container, {
              opacity: 0,
              x: initialX,
              y: initialY,
              duration: 0.6,
              ease: 'power2.in',
            });
          },
        });

        // Check initial state - if we're already in the trigger zone, show the nav
        // This handles page refreshes mid-scroll
        if (glideScrollTrigger.isActive) {
          gsap.set(container, {
            opacity: 1,
            x: 0,
            y: 0,
          });
        }
      };

      waitForWrapper();
    }
  }

  function initReaderNav(): void {
    const navs = document.querySelectorAll('[data-reader-nav]');
    navs.forEach((nav) => new ReaderNav(nav as HTMLElement));
  }

  // Initialize on load and page transitions
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initReaderNav);
  } else {
    initReaderNav();
  }

  document.addEventListener('astro:page-load', initReaderNav);
</script>
