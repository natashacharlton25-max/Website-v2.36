---
/**
 * ScrollGradientSection - GSAP ScrollTrigger powered gradient backgrounds
 *
 * Features:
 * - Scroll-triggered gradient flow (position controlled by scroll %)
 * - Scroll-activated animation (starts when section enters viewport)
 * - Parallax gradient (moves at different speed than scroll)
 * - Color morphing (colors shift based on scroll position)
 * - Performance optimized with will-change
 *
 * Usage:
 * ```astro
 * <ScrollGradientSection
 *   variant="scroll-flow"
 *   colors={['#818cf8', '#ec4899', '#4f46e5', '#db2777']}
 *   direction="horizontal"
 * >
 *   <h1>Your content here</h1>
 * </ScrollGradientSection>
 * ```
 */

interface Props {
  /**
   * Animation variant
   * - scroll-flow: Gradient position tied to scroll progress
   * - scroll-activate: Animation starts when section enters viewport
   * - parallax: Gradient moves at different speed than scroll
   * - color-morph: Colors shift/blend based on scroll position (hue-rotate)
   * - solid-morph: Solid colors transition based on scroll progress
   * - follow-viewport: Gradient follows viewport position
   */
  variant?: 'scroll-flow' | 'scroll-activate' | 'parallax' | 'color-morph' | 'solid-morph' | 'follow-viewport';

  /**
   * Gradient colors (array of hex colors)
   */
  colors?: string[];

  /**
   * Gradient direction
   */
  direction?: 'horizontal' | 'vertical' | 'diagonal' | 'radial';

  /**
   * Parallax speed multiplier (for parallax variant)
   * < 1 = slower than scroll, > 1 = faster than scroll
   */
  parallaxSpeed?: number;

  /**
   * Section height (CSS value)
   */
  height?: string;

  /**
   * Animation duration for scroll-activate variant (seconds)
   */
  duration?: number;

  /**
   * Start trigger position (ScrollTrigger format)
   */
  triggerStart?: string;

  /**
   * End trigger position (ScrollTrigger format)
   */
  triggerEnd?: string;

  /**
   * Enable scrub (smooth scroll-linked animation)
   */
  scrub?: boolean | number;

  /**
   * Additional CSS class
   */
  class?: string;

  /**
   * Enable debug markers (for development)
   */
  debug?: boolean;

  /**
   * Fixed background (covers full viewport, stays behind content)
   * Useful for page-wide scroll-triggered backgrounds
   */
  fixed?: boolean;
}

const {
  variant = 'scroll-flow',
  colors = ['#818cf8', '#ec4899', '#4f46e5', '#db2777', '#818cf8'],
  direction = 'horizontal',
  parallaxSpeed = 0.5,
  height = '100vh',
  duration = 2,
  triggerStart = 'top bottom',
  triggerEnd = 'bottom top',
  scrub = true,
  class: className = '',
  debug = false,
  fixed = false
} = Astro.props;

const sectionId = `scroll-gradient-${Math.random().toString(36).substring(2, 9)}`;

// Build gradient based on direction
const gradientDirection = {
  horizontal: '90deg',
  vertical: '180deg',
  diagonal: '135deg',
  radial: 'circle at center'
}[direction];

const gradientType = direction === 'radial' ? 'radial-gradient' : 'linear-gradient';
const colorStops = colors.join(', ');
---

<section
  class={`scroll-gradient-section scroll-gradient--${variant} ${fixed ? 'scroll-gradient--fixed' : ''} ${className}`}
  id={sectionId}
  data-variant={variant}
  data-colors={JSON.stringify(colors)}
  data-direction={direction}
  data-parallax-speed={parallaxSpeed}
  data-duration={duration}
  data-trigger-start={triggerStart}
  data-trigger-end={triggerEnd}
  data-scrub={scrub}
  data-debug={debug}
  data-fixed={fixed}
  style={`--section-height: ${height}; --gradient-direction: ${gradientDirection}; --gradient-colors: ${colorStops}; --solid-start-color: ${colors[0] || '#f8f5f2'};`}
>
  <div class="scroll-gradient-bg"></div>
  <div class="scroll-gradient-content">
    <slot />
  </div>
</section>

<style>
  .scroll-gradient-section {
    position: relative;
    min-height: var(--section-height, 100vh);
    overflow: hidden;
    isolation: isolate;
  }

  .scroll-gradient-bg {
    position: absolute;
    inset: 0;
    z-index: -1;
    will-change: background-position, background-size, opacity;
  }

  /* Horizontal gradient */
  .scroll-gradient--scroll-flow .scroll-gradient-bg,
  .scroll-gradient--scroll-activate .scroll-gradient-bg,
  .scroll-gradient--parallax .scroll-gradient-bg {
    background: linear-gradient(var(--gradient-direction), var(--gradient-colors));
    background-size: 300% 300%;
    background-position: 0% 50%;
  }

  /* Radial variant */
  .scroll-gradient-section[data-direction="radial"] .scroll-gradient-bg {
    background: radial-gradient(circle at center, var(--gradient-colors));
    background-size: 200% 200%;
    background-position: center;
  }

  /* Color morph uses multiple overlapping gradients */
  .scroll-gradient--color-morph .scroll-gradient-bg {
    background: linear-gradient(var(--gradient-direction), var(--gradient-colors));
    background-size: 100% 100%;
  }

  /* Follow viewport has fixed positioning effect */
  .scroll-gradient--follow-viewport .scroll-gradient-bg {
    background: linear-gradient(var(--gradient-direction), var(--gradient-colors));
    background-size: 300% 300%;
    background-attachment: fixed;
  }

  /* Solid morph - transitions between solid colors */
  .scroll-gradient--solid-morph .scroll-gradient-bg {
    background-color: var(--solid-start-color, #f8f5f2);
    transition: none; /* GSAP handles transitions */
  }

  .scroll-gradient-content {
    position: relative;
    z-index: 1;
    min-height: inherit;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
  }

  /* Fixed positioning for page-wide backgrounds */
  .scroll-gradient--fixed {
    position: static;
    min-height: auto;
  }

  .scroll-gradient--fixed .scroll-gradient-bg {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
  }

  .scroll-gradient--fixed .scroll-gradient-content {
    position: relative;
    z-index: 1;
    min-height: auto;
    padding: 0;
  }

  /* Performance optimization */
  @media (prefers-reduced-motion: reduce) {
    .scroll-gradient-bg {
      animation: none !important;
      background-position: 50% 50% !important;
    }
  }

  /* =========================================================
     ACCESSIBILITY OVERRIDES
     Disable animations when a11y theme settings are active
     ========================================================= */
  :global(body.a11y-reduce-motion) .scroll-gradient-bg,
  :global(body.a11y-text-only) .scroll-gradient-bg,
  :global(body.a11y-theme-dark) .scroll-gradient-bg,
  :global(body.a11y-theme-cream) .scroll-gradient-bg,
  :global(body.a11y-theme-high-contrast) .scroll-gradient-bg,
  :global(body.a11y-theme-protanopia) .scroll-gradient-bg,
  :global(body.a11y-theme-deuteranopia) .scroll-gradient-bg,
  :global(body.a11y-theme-tritanopia) .scroll-gradient-bg,
  :global(body.a11y-theme-monochrome) .scroll-gradient-bg {
    animation: none !important;
    transition: none !important;
    background-position: 50% 50% !important;
  }
</style>

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  function initScrollGradient(section: HTMLElement) {
    // Skip initialization if a11y settings are active
    const a11yClasses = [
      'a11y-reduce-motion',
      'a11y-text-only',
      'a11y-theme-dark',
      'a11y-theme-cream',
      'a11y-theme-high-contrast',
      'a11y-theme-protanopia',
      'a11y-theme-deuteranopia',
      'a11y-theme-tritanopia',
      'a11y-theme-monochrome'
    ];

    const hasA11ySetting = a11yClasses.some(cls => document.body.classList.contains(cls));
    if (hasA11ySetting) {
      // Just set initial color for solid-morph variant
      const bg = section.querySelector('.scroll-gradient-bg') as HTMLElement;
      const colors = JSON.parse(section.dataset.colors || '[]');
      if (bg && colors[0]) {
        bg.style.backgroundColor = colors[0];
      }
      return;
    }

    const variant = section.dataset.variant;
    const colors = JSON.parse(section.dataset.colors || '[]');
    const direction = section.dataset.direction;
    const parallaxSpeed = parseFloat(section.dataset.parallaxSpeed || '0.5');
    const duration = parseFloat(section.dataset.duration || '2');
    const triggerStart = section.dataset.triggerStart || 'top bottom';
    const triggerEnd = section.dataset.triggerEnd || 'bottom top';
    const scrub = section.dataset.scrub === 'true' ? true :
                  section.dataset.scrub === 'false' ? false :
                  parseFloat(section.dataset.scrub || '1');
    const debug = section.dataset.debug === 'true';

    const bg = section.querySelector('.scroll-gradient-bg') as HTMLElement;
    if (!bg) return;

    switch (variant) {
      case 'scroll-flow':
        // Gradient position tied to scroll progress
        gsap.to(bg, {
          backgroundPosition: '100% 50%',
          ease: 'none',
          scrollTrigger: {
            trigger: section,
            start: triggerStart,
            end: triggerEnd,
            scrub: scrub,
            markers: debug
          }
        });
        break;

      case 'scroll-activate':
        // Animation starts when section enters viewport
        gsap.set(bg, { backgroundPosition: '0% 50%' });

        ScrollTrigger.create({
          trigger: section,
          start: 'top 80%',
          markers: debug,
          onEnter: () => {
            gsap.to(bg, {
              backgroundPosition: '100% 50%',
              duration: duration,
              ease: 'power2.inOut',
              repeat: -1,
              yoyo: true
            });
          },
          onLeave: () => {
            gsap.killTweensOf(bg);
          },
          onEnterBack: () => {
            gsap.to(bg, {
              backgroundPosition: '100% 50%',
              duration: duration,
              ease: 'power2.inOut',
              repeat: -1,
              yoyo: true
            });
          },
          onLeaveBack: () => {
            gsap.killTweensOf(bg);
          }
        });
        break;

      case 'parallax':
        // Gradient moves at different speed than scroll
        const isVertical = direction === 'vertical' || direction === 'diagonal';

        gsap.to(bg, {
          backgroundPosition: isVertical ? '50% 100%' : '100% 50%',
          ease: 'none',
          scrollTrigger: {
            trigger: section,
            start: triggerStart,
            end: triggerEnd,
            scrub: parallaxSpeed,
            markers: debug
          }
        });
        break;

      case 'color-morph':
        // Colors shift based on scroll position
        // Create color stops that interpolate
        const colorStops = colors.length;

        gsap.to(bg, {
          '--morph-progress': 1,
          ease: 'none',
          scrollTrigger: {
            trigger: section,
            start: triggerStart,
            end: triggerEnd,
            scrub: scrub,
            markers: debug,
            onUpdate: (self) => {
              const progress = self.progress;
              // Shift hue based on scroll
              const hueShift = progress * 60; // 60 degree shift
              bg.style.filter = `hue-rotate(${hueShift}deg)`;
            }
          }
        });
        break;

      case 'follow-viewport':
        // Gradient follows viewport as you scroll
        ScrollTrigger.create({
          trigger: section,
          start: triggerStart,
          end: triggerEnd,
          scrub: scrub,
          markers: debug,
          onUpdate: (self) => {
            const progress = self.progress;
            const xPos = 50 + (progress - 0.5) * 100;
            const yPos = progress * 100;
            bg.style.backgroundPosition = `${xPos}% ${yPos}%`;
          }
        });
        break;

      case 'solid-morph':
        // Solid colors transition based on scroll progress
        // Convert any color format (including OKLCH) to RGB
        const toRGB = (color: string): string => {
          const temp = document.createElement('div');
          temp.style.backgroundColor = color;
          temp.style.display = 'none';
          document.body.appendChild(temp);
          const computed = getComputedStyle(temp).backgroundColor;
          document.body.removeChild(temp);
          return computed;
        };

        // Resolve CSS variable to RGB
        const resolveColor = (cssVar: string, fallback: string): string => {
          if (!cssVar) return fallback;
          let rawColor = cssVar;
          if (cssVar.startsWith('var(')) {
            const varName = cssVar.match(/var\((.*?)\)/)?.[1];
            if (varName) {
              rawColor = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
              if (!rawColor) return fallback;
            }
          }
          return toRGB(rawColor);
        };

        // Convert all colors to RGB
        const rgbColors = colors.map((c: string) => resolveColor(c, '#f8f5f2'));
        const fallbackRGB = rgbColors[0] || 'rgb(248, 245, 242)';

        // Set initial color
        bg.style.backgroundColor = rgbColors[0] || fallbackRGB;

        // Create scroll-linked color morph
        ScrollTrigger.create({
          trigger: section,
          start: triggerStart,
          end: triggerEnd,
          scrub: typeof scrub === 'number' ? scrub : 0.5,
          markers: debug,
          onUpdate: (self) => {
            const progress = self.progress;
            const numColors = rgbColors.length;

            if (numColors < 2) {
              bg.style.backgroundColor = rgbColors[0] || fallbackRGB;
              return;
            }

            // Calculate which two colors to interpolate between
            const scaledProgress = progress * (numColors - 1);
            const colorIndex = Math.floor(scaledProgress);
            const colorProgress = scaledProgress - colorIndex;

            const startIdx = Math.min(colorIndex, numColors - 1);
            const endIdx = Math.min(colorIndex + 1, numColors - 1);

            const startColor = rgbColors[startIdx];
            const endColor = rgbColors[endIdx];

            // Parse RGB values
            const parseRGB = (rgb: string) => {
              const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
              if (match) {
                return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
              }
              return [248, 245, 242]; // fallback
            };

            const start = parseRGB(startColor);
            const end = parseRGB(endColor);

            // Interpolate
            const r = Math.round(start[0] + (end[0] - start[0]) * colorProgress);
            const g = Math.round(start[1] + (end[1] - start[1]) * colorProgress);
            const b = Math.round(start[2] + (end[2] - start[2]) * colorProgress);

            bg.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          }
        });
        break;
    }
  }

  // Initialize all scroll gradient sections
  function init() {
    document.querySelectorAll('.scroll-gradient-section').forEach(section => {
      initScrollGradient(section as HTMLElement);
    });
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', init);
</script>
