---
/**
 * HeroMorphAnimation - Infinite looping SVG morph animation hero section
 * Tells a continuous story of growth through healing
 */

import UnifiedButton from '../Buttons/UnifiedButton.astro';

interface Props {
  ctaButtons?: Array<{ text: string; href: string; variant: 'primary' | 'outline' }>;
}

const { ctaButtons = [] } = Astro.props;

// Animation sequence configuration
const shapeSequence = [
  { file: '1.svg', text: "Walking With A Smile", holdTime: 2.0 },
  { file: 'circle1.svg', text: "What if healing looked different?", holdTime: 0.05 },
  { file: 'circles3.svg', text: "What if healing looked different?", holdTime: 2.0 },
  { file: '8.svg', text: "What if the hurt began to lift...", holdTime: 2.0 },
  { file: '3.svg', text: "and you saw your glow?", holdTime: 2.0 },
  { file: '4.svg', text: "What if you chose yourself?", holdTime: 2.0 },
  { file: '9.svg', text: "Gave yourself room to just be?", holdTime: 2.0 },
  { file: '7.svg', text: "and valued your worth?", holdTime: 2.0 },
  { file: '6.svg', text: "Listened to your own voice,", holdTime: 2.0 },
  { file: '2.svg', text: "and found a new path,", holdTime: 2.0 },
];
---

<section class="hero-morph">
  <div class="hero-container">
    <!-- Animated Title (spans full width above everything) -->
    <div class="title-stage">
      <h1 class="morph-text" data-morph-text></h1>
    </div>

    <!-- Left Side: Text -->
    <div class="hero-content">
      <!-- Static Subtitle -->
      <p class="hero-subtitle">
        Your past shaped you. It does not have to define you.<br><br>
        You have survived more than most people will ever fully understand. And now you might be wondering if life can feel different. Lighter. More yours.<br><br>
        <strong class="you-can">YOU CAN.</strong><br><br>
        Not because you forget what happened, or pretend it did not matter, but because you get to choose what happens next. You get to decide what healing looks like for you. At your pace. In your way.
      </p>

      <!-- CTA Buttons -->
      {ctaButtons.length > 0 && (
        <div class="hero-cta">
          {ctaButtons.map((button) => (
            <UnifiedButton
              href={button.href}
              variant={button.variant === 'outline' ? 'secondary' : 'primary'}
            >
              {button.text}
            </UnifiedButton>
          ))}
        </div>
      )}
    </div>

    <!-- Right Side: SVG Morph Animation -->
    <div class="morph-stage">
      <div class="svg-container" data-morph-container>
        <!-- SVG will be injected here by JS -->
      </div>
    </div>
  </div>

  <!-- Hidden SVG storage for morph targets -->
  <div style="display: none;" data-svg-storage>
    {shapeSequence.map((shape, index) => (
      <div data-svg-index={index} data-svg-file={shape.file} data-text={shape.text} data-hold-time={shape.holdTime}></div>
    ))}
  </div>
</section>

<style>
  .hero-morph {
    min-height: 100vh;
    display: flex;
    align-items: flex-start;
    justify-content: center;
    background-color: var(--color-Background-100);
    padding: var(--space-lg) var(--space-xl) var(--space-4xl) var(--space-md); /* Reduced left padding */
    position: relative;
    overflow: hidden;
  }

  .hero-container {
    max-width: 1400px; /* Increased for more text width */
    width: 100%;
    display: grid;
    grid-template-columns: 1fr 400px; /* Left content, right SVG */
    grid-template-rows: auto 1fr; /* Title row, content row */
    align-items: center; /* Center align items */
    gap: var(--space-md) var(--space-sm); /* Reduced horizontal gap between columns */
    z-index: 1;
    position: relative;
    margin-top: var(--space-3xl);
  }

  /* Title spans both columns */
  .title-stage {
    grid-column: 1 / -1; /* Span all columns */
    min-height: 140px; /* Min height for larger screens */
    height: auto; /* Allow to grow with content */
    width: 100%; /* Full width of container */
    max-width: none; /* Remove width constraints */
    z-index: 10;
    margin-bottom: 4rem; /* Increase gap between title and body text */
  }

  /* Left Content Area */
  .hero-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-xl);
    grid-column: 1;
    grid-row: 2;
    max-width: 600px; /* Constrain width for tighter wrapping */
  }

  .hero-subtitle {
    font-family: var(--font-body, 'Inter'), sans-serif;
    font-size: var(--text-lg, 1.125rem);
    line-height: var(--leading-relaxed, 1.625);
    color: var(--color-Text-600);
    margin: 0;
  }

  /* "YOU CAN." emphasis styling */
  .you-can {
    color: var(--color-Text-700);
    font-weight: var(--font-bold, 700);
    font-size: var(--text-xl);
  }

  /* SVG Morph Stage */
  .morph-stage {
    width: 400px;
    height: 400px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    grid-column: 2;
    grid-row: 2;
    justify-self: center; /* Center instead of end to move it left */
    align-self: center;
  }

  .svg-container {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: visible; /* Don't clip the circles */
  }

  .svg-container :global(svg) {
    width: 100%;
    height: 100%;
    fill: var(--color-Primary-600, #8B9D83);
    overflow: visible; /* Allow circles to extend beyond viewBox */
  }

  .svg-container :global(path) {
    fill: inherit;
    stroke: none;
  }

  /* Animated Title Text */
  h1.morph-text {
    font-family: var(--font-body, 'Quicksand'), sans-serif !important;
    font-size: clamp(1.5rem, 4vw + 1rem, 3.75rem) !important; /* Fluid responsive font */
    font-weight: var(--font-bold, 700) !important;
    color: var(--color-Text-700) !important;
    line-height: 1.4 !important; /* Better for wrapping */
    text-align: left !important; /* Left align to match subtitle */
    margin: 0 !important;
    padding-top: var(--space-2xl) !important; /* Adjusted title position */
    white-space: normal;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    transition: opacity 0.2s ease-in-out; /* Quick smooth fade */
  }

  /* CTA Buttons */
  .hero-cta {
    display: flex;
    gap: var(--space-md);
    flex-wrap: wrap;
    justify-content: flex-start;
    margin-top: var(--space-xl);
  }

  /* =============================================
     RESPONSIVE DESIGN
     ============================================= */

  /* Large screens - better margins (1500px - 1200px) */
  @media (max-width: 1500px) {
    .hero-morph {
      padding: var(--space-lg) var(--space-3xl) var(--space-4xl) var(--space-2xl);
    }

    .hero-container {
      max-width: 1200px;
      grid-template-columns: 1fr 310px;
    }

    .morph-stage {
      width: 310px;
      height: 310px;
    }
  }

  /* Medium-large screens (1200px - 968px) */
  @media (max-width: 1200px) {
    .hero-morph {
      padding: var(--space-lg) var(--space-2xl) var(--space-3xl) var(--space-xl);
    }

    .hero-container {
      max-width: 1000px;
      grid-template-columns: 1fr 250px;
      gap: var(--space-lg) var(--space-lg);
    }

    .morph-stage {
      width: 250px;
      height: 250px;
    }

    .hero-content {
      max-width: 550px;
    }

    .title-stage {
      min-height: 120px;
      margin-bottom: 2.5rem;
    }

    h1.morph-text {
      font-size: clamp(2.5rem, 4vw, 3rem) !important;
    }
  }

  /* Tablets (iPad portrait, etc.) */
  @media (max-width: 968px) {
    .hero-morph {
      padding: var(--space-xl) var(--space-lg) var(--space-3xl);
    }

    .hero-container {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
      gap: var(--space-xl);
      margin-top: var(--space-xl);
      text-align: center;
    }

    .title-stage {
      grid-column: 1;
      grid-row: 1;
      height: auto;
      min-height: 100px;
      margin-bottom: var(--space-md);
    }

    h1.morph-text {
      text-align: center !important;
      font-size: clamp(2rem, 5vw, 3rem) !important;
      padding-top: var(--space-xl) !important;
    }

    .hero-content {
      grid-column: 1;
      grid-row: 2;
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

    .hero-subtitle {
      text-align: center;
    }

    .hero-cta {
      justify-content: center;
    }

    .morph-stage {
      grid-column: 1;
      grid-row: 3;
      width: 100%;
      max-width: 380px;
      height: 380px;
      margin: 0 auto;
      justify-self: center;
    }
  }

  /* Large phones / Small tablets */
  @media (max-width: 768px) {
    .hero-morph {
      min-height: auto;
      padding: var(--space-lg) var(--space-md) var(--space-2xl);
    }

    .hero-container {
      margin-top: var(--space-lg);
      gap: var(--space-lg);
    }

    .title-stage {
      min-height: 80px;
      margin-bottom: 0;
    }

    h1.morph-text {
      font-size: clamp(1.5rem, 6vw, 2.25rem) !important;
      padding-top: var(--space-lg) !important;
      line-height: 1.3 !important;
    }

    .hero-subtitle {
      font-size: var(--text-base, 1rem);
      line-height: var(--leading-relaxed, 1.6);
    }

    .morph-stage {
      max-width: 320px;
      height: 320px;
    }

    .hero-cta {
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: var(--space-sm);
    }

    /* Make buttons full width on mobile */
    .hero-cta :global(.unified-btn) {
      width: 100%;
      max-width: 280px;
    }

    .hero-cta :global(.unified-btn > *) {
      width: 100%;
    }
  }

  /* Small phones */
  @media (max-width: 480px) {
    .hero-morph {
      padding: var(--space-md) var(--space-sm) var(--space-xl);
    }

    .hero-container {
      gap: var(--space-md);
    }

    .title-stage {
      min-height: 70px;
    }

    h1.morph-text {
      font-size: clamp(1.25rem, 7vw, 1.875rem) !important;
      padding-top: var(--space-md) !important;
      line-height: 1.25 !important;
    }

    .hero-subtitle {
      font-size: var(--text-sm, 0.875rem);
    }

    .morph-stage {
      max-width: 260px;
      height: 260px;
    }

    .hero-cta :global(.unified-btn) {
      max-width: 100%;
    }
  }

  /* Very small screens */
  @media (max-width: 360px) {
    .hero-morph {
      padding: var(--space-sm) var(--space-xs) var(--space-lg);
    }

    .title-stage {
      min-height: 60px;
    }

    h1.morph-text {
      font-size: clamp(1rem, 8vw, 1.5rem) !important;
      line-height: 1.2 !important;
    }

    .hero-subtitle {
      font-size: var(--text-xs, 0.75rem);
    }

    .morph-stage {
      max-width: 220px;
      height: 220px;
    }
  }

  /* Ultra small screens - hide SVG animation */
  @media (max-width: 200px) {
    .morph-stage {
      display: none;
    }
  }
</style>

<script>
  import { gsap } from 'gsap';
  import { MorphSVGPlugin } from 'gsap/MorphSVGPlugin';

  gsap.registerPlugin(MorphSVGPlugin);

  // Animation configuration
  const CONFIG = {
    morphDuration: 1.8,  // Slower for smoother morphing
    textFadeIn: 0.6,  // Slower fade for smoother text transitions
    textHold: 2.0,
  };

  async function loadSVG(filename: string): Promise<string> {
    try {
      // Special case: Generate single circle (same size as diverging circles)
      if (filename === 'circle1.svg') {
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';
        return `<?xml version="1.0" encoding="UTF-8"?>
          <svg width="100%" height="100%" viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg">
            <path d="${circlePath}" fill="#8B9D83" fill-opacity="0.98"/>
          </svg>`;
      }

      // Special case: Generate 3 circles (positioned left, center, right) - same size as circle1
      if (filename === 'circles3.svg') {
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';
        return `<?xml version="1.0" encoding="UTF-8"?>
          <svg width="100%" height="100%" viewBox="0 0 1000 1000" xmlns="http://www.w3.org/2000/svg">
            <path d="${circlePath}" fill="#8B9D83" fill-opacity="0.98" data-position="center"/>
            <path d="${circlePath}" fill="#8B9D83" fill-opacity="0.98" data-position="left"/>
            <path d="${circlePath}" fill="#8B9D83" fill-opacity="0.98" data-position="right"/>
          </svg>`;
      }

      const response = await fetch(`/Homepage hero animation WWAS/${filename}`);
      return await response.text();
    } catch (error) {
      console.error(`Failed to load SVG: ${filename}`, error);
      return '';
    }
  }

  async function initHeroMorph() {
    const container = document.querySelector('[data-morph-container]') as HTMLElement;
    const textElement = document.querySelector('[data-morph-text]') as HTMLElement;
    const storage = document.querySelector('[data-svg-storage]');

    if (!container || !textElement || !storage) return;

    // Get sequence data from hidden storage
    const sequenceData = Array.from(storage.querySelectorAll('[data-svg-index]')).map(el => ({
      file: el.getAttribute('data-svg-file') || '',
      text: el.getAttribute('data-text') || '',
      holdTime: parseFloat(el.getAttribute('data-hold-time') || '2.8'),
    }));

    // Load all SVGs
    const svgCache = new Map<string, string>();
    for (const shape of sequenceData) {
      const svgContent = await loadSVG(shape.file);
      svgCache.set(shape.file, svgContent);
    }

    // Create initial SVG
    const firstSVG = svgCache.get(sequenceData[0].file);
    if (!firstSVG) return;

    container.innerHTML = firstSVG;
    const svg = container.querySelector('svg');
    if (!svg) return;

    let currentIndex = 0;
    let isLooping = false;

    async function showText(text: string) {
      // Fade out with moderate blur - opacity does most of the work
      await gsap.to(textElement, {
        opacity: 0,
        filter: 'blur(20px)', // Moderate blur for smooth effect
        duration: 1.0,
        ease: 'power3.in',
      });

      // Extra pause to ensure absolute invisibility
      await gsap.to({}, { duration: 0.15 });

      // Change text while completely invisible
      textElement.textContent = text;

      // Set starting state for fade in - text is invisible and blurred
      gsap.set(textElement, { opacity: 0, filter: 'blur(20px)' });

      // Smooth fade in with deblur from complete invisibility
      await gsap.to(textElement, {
        opacity: 1,
        filter: 'blur(0px)',
        duration: 1.4,
        ease: 'power2.out',
      });
    }

    async function morphToNext() {
      // Stop if we're at the logo and have already looped once
      if (currentIndex === 0 && isLooping) {
        return;
      }

      const nextIndex = (currentIndex + 1) % sequenceData.length;
      const nextShape = sequenceData[nextIndex];
      const nextSVG = svgCache.get(nextShape.file);

      if (!nextSVG) return;

      // Parse next SVG
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = nextSVG;
      const targetSVG = tempDiv.querySelector('svg');
      if (!targetSVG) return;

      if (!svg) return;
      const currentPaths = Array.from(svg.querySelectorAll('path'));
      const targetPaths = Array.from(targetSVG.querySelectorAll('path'));

      // Check if text is changing
      const currentText = sequenceData[currentIndex].text;
      const nextText = nextShape.text;
      const textChanging = currentText !== nextText;

      // Start text change in parallel (don't await) so it happens during SVG morph
      if (textChanging && nextText) {
        showText(nextText); // Run in parallel, don't wait
      }

      // Morph SVG - Simple approach: always replace entire SVG
      const timeline = gsap.timeline();

      // Get current and next file names for special handling
      const currentFile = sequenceData[currentIndex].file;
      const nextFile = nextShape.file;

      // Special case: Circle1 -> Circles3 (Divergence animation)
      if (currentFile === 'circle1.svg' && nextFile === 'circles3.svg') {
        // All same size circles (radius 100)
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';
        const centerPath = currentPaths[0];

        // Create 2 additional circles at center position (fully visible)
        const leftCircle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        leftCircle.setAttribute('d', circlePath);
        leftCircle.setAttribute('fill', '#8B9D83');
        leftCircle.style.opacity = '1';
        leftCircle.setAttribute('data-position', 'left');
        svg.appendChild(leftCircle);

        const rightCircle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        rightCircle.setAttribute('d', circlePath);
        rightCircle.setAttribute('fill', '#8B9D83');
        rightCircle.style.opacity = '1';
        rightCircle.setAttribute('data-position', 'right');
        svg.appendChild(rightCircle);

        // Animate divergence - smoother and slower
        const divergeDuration = 0.9;
        const horizontalOffset = 250;

        // Center circle stays, left and right diverge (no opacity change, just movement)
        timeline.to(leftCircle, {
          x: -horizontalOffset,
          duration: divergeDuration,
          ease: 'power1.inOut',
        }, 0);

        timeline.to(rightCircle, {
          x: horizontalOffset,
          duration: divergeDuration,
          ease: 'power1.inOut',
        }, 0);

        // Mark center circle with data attribute for later
        centerPath.setAttribute('data-position', 'center');

        // Wait for divergence to complete
        await timeline;

        currentIndex = nextIndex;

        // Mark that we've completed one loop when we return to logo
        if (nextIndex === 0) isLooping = true;

        const holdTime = nextShape.holdTime || CONFIG.textHold;
        await gsap.to({}, { duration: holdTime });
        morphToNext();
        return;
      }

      // Special case: Circles3 -> anything (Convergence animation first)
      if (currentFile === 'circles3.svg') {
        const convergeDuration = 0.8; // Smoother, slower convergence

        // Get all circles by their data-position attributes
        const centerCircle = currentPaths.find(p => p.getAttribute('data-position') === 'center');
        const leftCircle = currentPaths.find(p => p.getAttribute('data-position') === 'left');
        const rightCircle = currentPaths.find(p => p.getAttribute('data-position') === 'right');

        if (leftCircle && rightCircle) {
          // Step 1: Move circles to center (no fade during movement)
          timeline.to(leftCircle, {
            x: 0,
            duration: convergeDuration,
            ease: 'power1.inOut',
          }, 0);

          timeline.to(rightCircle, {
            x: 0,
            duration: convergeDuration,
            ease: 'power1.inOut',
          }, 0);

          // Wait for movement to complete
          await timeline;

          // Step 2: Quick fade out AFTER they reach center
          const fadeTimeline = gsap.timeline();
          fadeTimeline.to([leftCircle, rightCircle], {
            opacity: 0,
            duration: 0.15,
            ease: 'power1.in',
          });

          await fadeTimeline;

          // Remove the circles
          leftCircle.remove();
          rightCircle.remove();

          // Now continue with normal morph from center circle to target
          // Update currentPaths to just the center circle
          const remainingPath = centerCircle;
          if (!remainingPath) return;

          // Create new timeline for the morph
          const morphTimeline = gsap.timeline();

          // Morph center circle to target (single path)
          if (targetPaths.length === 1) {
            morphTimeline.to(remainingPath, {
              morphSVG: { shape: targetPaths[0], type: 'rotational' },
              duration: CONFIG.morphDuration,
              ease: 'power2.inOut',
            }, 0);
          } else {
            // If target has multiple paths, use the multi-path logic
            const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';

            // Morph to circle first
            morphTimeline.to(remainingPath, {
              morphSVG: circlePath,
              duration: 0.25,
              ease: 'power2.inOut',
            }, 0);

            // Create additional circles
            const additionalCircles: SVGPathElement[] = [];
            for (let i = 1; i < targetPaths.length; i++) {
              const circle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              circle.setAttribute('d', circlePath);
              circle.setAttribute('fill', '#8B9D83');
              circle.style.opacity = '0';
              svg.appendChild(circle);
              additionalCircles.push(circle);

              morphTimeline.to(circle, {
                opacity: 1,
                duration: 0.15,
              }, 0.15);
            }

            // Morph all circles to target paths
            const allCircles = [remainingPath, ...additionalCircles];
            allCircles.forEach((circle, i) => {
              morphTimeline.to(circle, {
                morphSVG: { shape: targetPaths[i], type: 'rotational' },
                duration: CONFIG.morphDuration,
                ease: 'power2.inOut',
              }, 0.2);
            });
          }

          await morphTimeline;

          currentIndex = nextIndex;

          // Mark that we've completed one loop when we return to logo
          if (nextIndex === 0) isLooping = true;

          const holdTime = nextShape.holdTime || CONFIG.textHold;
          await gsap.to({}, { duration: holdTime });
          morphToNext();
          return;
        }
      }

      // Handle multi-path (logo with 4 separate paths) to single-path transitions
      if (currentPaths.length > 1 && targetPaths.length === 1) {
        const targetPath = targetPaths[0];

        // Create a circle path for intermediate step (radius 100)
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';

        // Smooth transition with visible circle intermediate state
        const circleTransitionDuration = 0.8; // Morph to circles
        const circleFadeDuration = 0.3; // Fade out extra circles
        const targetMorphDuration = 1.0; // Morph from circle to target

        // Step 1: Morph all paths to circles
        currentPaths.forEach(path => {
          timeline.to(path, {
            morphSVG: circlePath,
            duration: circleTransitionDuration,
            ease: 'power2.inOut',
          }, 0);
        });

        // Step 2: Fade out extra circles - start near end of circle morph
        currentPaths.slice(1).forEach(path => {
          timeline.to(path, {
            opacity: 0,
            duration: circleFadeDuration,
            ease: 'power1.inOut',
            onComplete: () => path.remove(),
          }, circleTransitionDuration * 0.7); // Start near end so circle is visible
        });

        // Step 3: Wait for circle to fully form, THEN morph to target
        const morphStartTime = circleTransitionDuration + circleFadeDuration; // Start AFTER circle is fully formed and extras faded
        timeline.to(currentPaths[0], {
          morphSVG: { shape: targetPath, type: 'rotational' },
          duration: targetMorphDuration,
          ease: 'power2.inOut',
        }, morphStartTime);

      } else if (currentPaths.length === 1 && targetPaths.length > 1) {
        // Single to Multi: Morph to circle, spawn more circles, morph all to targets
        const currentPath = currentPaths[0];
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';

        // Smooth transition with visible circle intermediate state
        const circleTransitionDuration = 0.8; // Morph to circle
        const circleFadeDuration = 0.3; // Fade in additional circles
        const targetMorphDuration = 1.0; // Morph from circles to target

        // Step 1: Morph current to circle
        timeline.to(currentPath, {
          morphSVG: circlePath,
          duration: circleTransitionDuration,
          ease: 'power2.inOut',
        }, 0);

        // Step 2: Create additional circles and fade them in - start near end of circle morph
        const additionalCircles: SVGPathElement[] = [];
        for (let i = 1; i < targetPaths.length; i++) {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          circle.setAttribute('d', circlePath);
          circle.setAttribute('fill', '#8B9D83');
          circle.style.opacity = '0';
          svg.appendChild(circle);
          additionalCircles.push(circle);

          timeline.to(circle, {
            opacity: 1,
            duration: circleFadeDuration,
            ease: 'power1.inOut',
          }, circleTransitionDuration * 0.7); // Start near end so circle is visible
        }

        // Step 3: Wait for circles to fully form, THEN morph to target
        const allCircles = [currentPath, ...additionalCircles];
        const morphStartTime = circleTransitionDuration + circleFadeDuration; // Start AFTER circles are fully formed
        allCircles.forEach((circle, i) => {
          timeline.to(circle, {
            morphSVG: { shape: targetPaths[i], type: 'rotational' },
            duration: targetMorphDuration,
            ease: 'power2.inOut',
          }, morphStartTime);
        });

      } else if (currentPaths.length === 1 && targetPaths.length === 1) {
        const currentPath = currentPaths[0];
        const targetPath = targetPaths[0];

        // Count sub-paths within each path
        const currentSubPathCount = (currentPath.getAttribute('d') || '').split(/[Mm]/).length - 1;
        const targetSubPathCount = (targetPath.getAttribute('d') || '').split(/[Mm]/).length - 1;

        if (currentSubPathCount > 1 && targetSubPathCount === 1) {
          // Multi to Single: Extract first sub-path, fade out original, morph first to target
          const pathData = currentPath.getAttribute('d') || '';
          const subPaths = pathData.split(/(?=[Mm])/).filter(p => p.trim());

          // Create temp path with just first sub-path
          const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          tempPath.setAttribute('d', subPaths[0]);
          tempPath.setAttribute('fill', '#8B9D83');
          tempPath.style.opacity = '0';
          svg.appendChild(tempPath);

          // Fade out original multi-part path, fade in temp single path
          timeline.to(currentPath, { opacity: 0, duration: 0.3 }, 0);
          timeline.to(tempPath, { opacity: 1, duration: 0.3 }, 0);

          // Morph temp to target
          timeline.to(tempPath, {
            morphSVG: { shape: targetPath, type: 'rotational' },
            duration: CONFIG.morphDuration,
            ease: 'power2.inOut',
          }, 0.3);

        } else if (currentSubPathCount === 1 && targetSubPathCount > 1) {
          // Single to Multi: Morph to first part, then scale up + fade in full target
          const targetData = targetPath.getAttribute('d') || '';
          const targetSubPaths = targetData.split(/(?=[Mm])/).filter(p => p.trim());

          // Create temp path with just first sub-path of target
          const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          tempPath.setAttribute('d', targetSubPaths[0]);
          tempPath.setAttribute('fill', '#8B9D83');

          // Morph current to first part of target
          timeline.to(currentPath, {
            morphSVG: { shape: tempPath, type: 'rotational' },
            duration: CONFIG.morphDuration,
            ease: 'power2.inOut',
          }, 0);

          // Replace with full target and scale up + fade in
          timeline.call(() => {
            svg.innerHTML = '';
            const fullTarget = targetPath.cloneNode(true) as SVGPathElement;
            fullTarget.style.opacity = '0';
            svg.appendChild(fullTarget);

            // Scale up from small while fading in (extra parts grow from center)
            gsap.fromTo(fullTarget,
              {
                opacity: 0,
                scale: 0.3,
                transformOrigin: '50% 50%'
              },
              {
                opacity: 1,
                scale: 1,
                duration: 0.5,
                ease: 'back.out(1.2)'
              }
            );
          }, undefined, CONFIG.morphDuration);

        } else if (currentSubPathCount > 1 && targetSubPathCount > 1) {
          // Multi to Multi: Scale down old, scale up new with crossfade
          timeline.to(currentPath, {
            opacity: 0,
            scale: 0.4,
            transformOrigin: '50% 50%',
            duration: CONFIG.morphDuration / 2,
            ease: 'power2.in'
          }, 0);

          timeline.call(() => {
            svg.innerHTML = '';
            const fullTarget = targetPath.cloneNode(true) as SVGPathElement;
            fullTarget.style.opacity = '0';
            svg.appendChild(fullTarget);

            gsap.fromTo(fullTarget,
              {
                opacity: 0,
                scale: 0.4,
                transformOrigin: '50% 50%'
              },
              {
                opacity: 1,
                scale: 1,
                duration: CONFIG.morphDuration / 2,
                ease: 'power2.out'
              }
            );
          }, undefined, CONFIG.morphDuration / 2);

        } else {
          // Normal single-to-single morph
          timeline.to(currentPath, {
            morphSVG: { shape: targetPath, type: 'rotational' },
            duration: CONFIG.morphDuration,
            ease: 'power2.inOut',
          }, 0);
        }
      } else {
        // Multi-to-Multi transitions (e.g., smile 3 paths → logo 4 paths)
        const circlePath = 'M500,400 C555.228,400 600,444.772 600,500 C600,555.228 555.228,600 500,600 C444.772,600 400,555.228 400,500 C400,444.772 444.772,400 500,400Z';

        if (currentPaths.length < targetPaths.length) {
          // Need MORE paths (e.g., smile 3 → logo 4)
          // Smooth transition with visible circle intermediate state
          const circleTransitionDuration = 0.8; // Morph to circles
          const circleFadeDuration = 0.3; // Fade in additional circles
          const targetMorphDuration = 1.0; // Morph from circles to target

          // Step 1: Morph all current paths to circles
          currentPaths.forEach(path => {
            timeline.to(path, {
              morphSVG: circlePath,
              duration: circleTransitionDuration,
              ease: 'power2.inOut',
            }, 0);
          });

          // Step 2: Create and fade in additional circles - start near end of circle morph
          const additionalCircles: SVGPathElement[] = [];
          const numToCreate = targetPaths.length - currentPaths.length;
          for (let i = 0; i < numToCreate; i++) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            circle.setAttribute('d', circlePath);
            circle.setAttribute('fill', '#8B9D83');
            circle.style.opacity = '0';
            svg.appendChild(circle);
            additionalCircles.push(circle);

            timeline.to(circle, {
              opacity: 1,
              duration: circleFadeDuration,
              ease: 'power1.inOut',
            }, circleTransitionDuration * 0.7); // Start near end so circle is visible
          }

          // Step 3: Wait for circles to fully form, THEN morph to target
          const allCircles = [...currentPaths, ...additionalCircles];
          const morphStartTime = circleTransitionDuration + circleFadeDuration; // Start AFTER circles are fully formed
          allCircles.forEach((circle, i) => {
            timeline.to(circle, {
              morphSVG: { shape: targetPaths[i], type: 'rotational' },
              duration: targetMorphDuration,
              ease: 'power2.inOut',
            }, morphStartTime);
          });

        } else if (currentPaths.length > targetPaths.length) {
          // Need FEWER paths (e.g., logo 4 → smile 3)
          // Smooth transition with visible circle intermediate state
          const circleTransitionDuration = 0.8; // Morph to circles
          const circleFadeDuration = 0.3; // Fade out extra circles
          const targetMorphDuration = 1.0; // Morph from circles to target

          // Step 1: Morph all to circles
          currentPaths.forEach(path => {
            timeline.to(path, {
              morphSVG: circlePath,
              duration: circleTransitionDuration,
              ease: 'power2.inOut',
            }, 0);
          });

          // Step 2: Fade out extra circles - start near end of circle morph
          const numToRemove = currentPaths.length - targetPaths.length;
          currentPaths.slice(-numToRemove).forEach(path => {
            timeline.to(path, {
              opacity: 0,
              duration: circleFadeDuration,
              ease: 'power1.inOut',
              onComplete: () => path.remove(),
            }, circleTransitionDuration * 0.7); // Start near end so circle is visible
          });

          // Step 3: Wait for circles to fully form, THEN morph to target
          const morphStartTime = circleTransitionDuration + circleFadeDuration; // Start AFTER circles are fully formed
          currentPaths.slice(0, targetPaths.length).forEach((circle, i) => {
            timeline.to(circle, {
              morphSVG: { shape: targetPaths[i], type: 'rotational' },
              duration: targetMorphDuration,
              ease: 'power2.inOut',
            }, morphStartTime);
          });

        } else {
          // Same number of paths - direct morph
          currentPaths.forEach((path, i) => {
            timeline.to(path, {
              morphSVG: { shape: targetPaths[i], type: 'rotational' },
              duration: CONFIG.morphDuration,
              ease: 'power2.inOut',
            }, 0);
          });
        }
      }

      // Wait for morph to complete
      await timeline;

      currentIndex = nextIndex;

      // Mark that we've completed one loop when we return to logo
      if (nextIndex === 0) isLooping = true;

      // Wait before next morph (use custom hold time or default)
      const holdTime = nextShape.holdTime || CONFIG.textHold;
      await gsap.to({}, { duration: holdTime });

      // Continue the loop
      morphToNext();
    }

    // Start the animation - show initial text immediately (no fade)
    textElement.textContent = sequenceData[0].text;
    gsap.set(textElement, { opacity: 1, filter: 'blur(0px)' });
    await gsap.to({}, { duration: CONFIG.textHold });
    morphToNext();
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHeroMorph);
  } else {
    initHeroMorph();
  }

  // Support Astro page transitions
  document.addEventListener('astro:page-load', initHeroMorph);
</script>
