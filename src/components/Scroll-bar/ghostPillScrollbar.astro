---
/**
 * Custom Scrollbar Component
 * Inspired by Locomotive Scroll's custom scrollbar
 *
 * Usage: <CustomScrollbar /> - add to any page/layout
 *
 * Props:
 * @param position - 'left' | 'right' (default: 'right')
 * @param theme - 'light' | 'dark' | 'primary' (default: 'dark')
 * @param width - Scrollbar width in px (default: 8)
 * @param showOnMobile - Show on mobile devices (default: false)
 */

interface Props {
  position?: 'left' | 'right';
  theme?: 'light' | 'dark' | 'primary';
  width?: number;
  showOnMobile?: boolean;
}

const {
  position = 'right',
  theme = 'dark',
  width = 8,
  showOnMobile = false,
} = Astro.props;
---

<div
  class={`c-scrollbar c-scrollbar--${position} c-scrollbar--${theme}`}
  style={`--scrollbar-width: ${width}px`}
  data-scrollbar
  data-show-mobile={showOnMobile}
>
  <span class="c-scrollbar_thumb"></span>
</div>

<style define:vars={{ width: `${width}px` }}>
  .c-scrollbar {
    position: fixed;
    top: 0;
    width: var(--scrollbar-width, 8px);
    height: 100vh;
    z-index: 9998;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .c-scrollbar.is-visible {
    opacity: 1;
  }

  .c-scrollbar--right {
    right: 4px;
  }

  .c-scrollbar--left {
    left: 4px;
  }

  .c-scrollbar_thumb {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    border-radius: 99px;
    pointer-events: auto;
    cursor: grab;
    transition: background-color 0.2s ease, width 0.2s ease;
  }

  .c-scrollbar_thumb:active {
    cursor: grabbing;
  }

  /* Theme: Dark (default) */
  .c-scrollbar--dark .c-scrollbar_thumb {
    background-color: rgba(0, 0, 0, 0.3);
  }

  .c-scrollbar--dark .c-scrollbar_thumb:hover {
    background-color: rgba(0, 0, 0, 0.5);
  }

  /* Theme: Light */
  .c-scrollbar--light .c-scrollbar_thumb {
    background-color: rgba(255, 255, 255, 0.3);
  }

  .c-scrollbar--light .c-scrollbar_thumb:hover {
    background-color: rgba(255, 255, 255, 0.5);
  }

  /* Theme: Primary */
  .c-scrollbar--primary .c-scrollbar_thumb {
    background-color: var(--color-Primary-500, #2dd4bf);
    opacity: 0.6;
  }

  .c-scrollbar--primary .c-scrollbar_thumb:hover {
    opacity: 1;
  }

  /* Hover state - make wider */
  .c-scrollbar:hover .c-scrollbar_thumb {
    width: calc(var(--scrollbar-width, 8px) + 4px);
  }

  /* Hide native scrollbar when custom scrollbar is active */
  :global(body.has-custom-scrollbar) {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
  }

  :global(body.has-custom-scrollbar::-webkit-scrollbar) {
    display: none; /* Chrome/Safari/Opera */
  }

  /* Hide on mobile by default */
  @media (max-width: 768px) {
    .c-scrollbar:not([data-show-mobile="true"]) {
      display: none;
    }
  }
</style>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  class CustomScrollbar {
    container: HTMLElement;
    thumb: HTMLElement;
    isDragging = false;
    startY = 0;
    startScrollY = 0;
    thumbHeight = 0;
    maxScroll = 0;
    trackHeight = 0;
    hideTimeout: ReturnType<typeof setTimeout> | null = null;

    constructor(container: HTMLElement) {
      this.container = container;
      this.thumb = container.querySelector('.c-scrollbar_thumb') as HTMLElement;

      if (!this.thumb) return;

      this.init();
    }

    init(): void {
      // Add class to body to hide native scrollbar
      document.body.classList.add('has-custom-scrollbar', 'hide-scrollbar');

      // Calculate dimensions
      this.updateDimensions();

      // Set up scroll listener using GSAP ScrollTrigger for smooth updates
      ScrollTrigger.create({
        trigger: document.documentElement,
        start: 'top top',
        end: 'bottom bottom',
        onUpdate: (self) => this.updateThumbPosition(self.progress),
      });

      // Set up drag functionality
      this.setupDrag();

      // Show scrollbar initially then fade
      this.showScrollbar();

      // Update on resize
      window.addEventListener('resize', () => this.updateDimensions());

      // Show on scroll
      window.addEventListener('scroll', () => this.showScrollbar(), { passive: true });
    }

    updateDimensions(): void {
      const docHeight = document.documentElement.scrollHeight;
      const viewportHeight = window.innerHeight;

      this.maxScroll = docHeight - viewportHeight;
      this.trackHeight = viewportHeight;

      // Calculate thumb height proportional to viewport/content ratio
      const ratio = viewportHeight / docHeight;
      this.thumbHeight = Math.max(ratio * viewportHeight, 40); // Min 40px

      this.thumb.style.height = `${this.thumbHeight}px`;
    }

    updateThumbPosition(progress: number): void {
      const maxThumbTravel = this.trackHeight - this.thumbHeight;
      const thumbY = progress * maxThumbTravel;

      gsap.set(this.thumb, {
        y: thumbY,
      });
    }

    showScrollbar(): void {
      this.container.classList.add('is-visible');

      // Hide after 2 seconds of inactivity
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
      }

      this.hideTimeout = setTimeout(() => {
        if (!this.isDragging) {
          this.container.classList.remove('is-visible');
        }
      }, 2000);
    }

    setupDrag(): void {
      this.thumb.addEventListener('mousedown', (e) => this.onDragStart(e));
      document.addEventListener('mousemove', (e) => this.onDragMove(e));
      document.addEventListener('mouseup', () => this.onDragEnd());

      // Touch support
      this.thumb.addEventListener('touchstart', (e) => this.onDragStart(e));
      document.addEventListener('touchmove', (e) => this.onDragMove(e));
      document.addEventListener('touchend', () => this.onDragEnd());

      // Click on track to jump
      this.container.addEventListener('click', (e) => this.onTrackClick(e));
    }

    onDragStart(e: MouseEvent | TouchEvent): void {
      e.preventDefault();
      this.isDragging = true;
      this.container.classList.add('is-visible');

      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
      this.startY = clientY;
      this.startScrollY = window.scrollY;

      document.body.style.userSelect = 'none';
    }

    onDragMove(e: MouseEvent | TouchEvent): void {
      if (!this.isDragging) return;

      const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
      const deltaY = clientY - this.startY;

      // Convert thumb movement to scroll movement
      const scrollRatio = this.maxScroll / (this.trackHeight - this.thumbHeight);
      const scrollDelta = deltaY * scrollRatio;

      window.scrollTo({
        top: this.startScrollY + scrollDelta,
        behavior: 'auto',
      });
    }

    onDragEnd(): void {
      if (!this.isDragging) return;

      this.isDragging = false;
      document.body.style.userSelect = '';

      // Start hide timer
      this.showScrollbar();
    }

    onTrackClick(e: MouseEvent): void {
      if (e.target === this.thumb) return;

      const rect = this.container.getBoundingClientRect();
      const clickY = e.clientY - rect.top;
      const clickRatio = clickY / this.trackHeight;

      window.scrollTo({
        top: clickRatio * this.maxScroll,
        behavior: 'smooth',
      });
    }
  }

  // Initialize all custom scrollbars
  document.querySelectorAll('[data-scrollbar]').forEach((el) => {
    new CustomScrollbar(el as HTMLElement);
  });
</script>
