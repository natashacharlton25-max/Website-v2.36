---
/**
 * MorphSVGIcon - Pure animation component for MorphSVG effects
 * Handles ONLY morph animation logic - parent controls size, colors, positioning
 *
 * Morphs between two SVG shapes with smooth transitions
 * Uses fill (not stroke) for morphing animations
 */

interface Props {
  /**
   * SVG icon markup for initial state (required)
   * Should contain <svg> with <path> elements for animation
   */
  svgIcon: string;

  /**
   * Target SVG for morphing (required)
   * Should have same number of paths as svgIcon
   */
  morphTarget: string;

  /**
   * Trigger animation on hover (default: true)
   * Set to false to trigger programmatically via CSS class or JS
   */
  animateOnHover?: boolean;

  /**
   * Primary color for the morph animation (CSS variable or hex)
   * Used as the target fill color during morph
   */
  primaryColor?: string;

  /**
   * Additional CSS class for custom styling from parent
   */
  class?: string;
}

const {
  svgIcon,
  morphTarget,
  animateOnHover = true,
  primaryColor,
  class: className = ''
} = Astro.props;

const iconId = `morph-icon-${Math.random().toString(36).substring(2, 9)}`;
---

<span
  class={`morph-svg-icon ${className}`}
  data-animation="morph"
  data-animate-on-hover={animateOnHover}
  data-morph-target={morphTarget}
  data-primary-color={primaryColor}
  id={iconId}
  set:html={svgIcon}
></span>

<style>
  .morph-svg-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .morph-svg-icon :global(svg) {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Morph animations use fills, not strokes */
  /* Parent controls the fill color via inheritance or CSS variables */
  .morph-svg-icon :global(path) {
    fill: inherit;
    stroke: none;
  }
</style>

<script>
  import { gsap } from 'gsap';
  import { MorphSVGPlugin } from 'gsap/MorphSVGPlugin';

  gsap.registerPlugin(MorphSVGPlugin);

  function initMorphIcon(iconElement: HTMLElement) {
    const animateOnHover = iconElement.dataset.animateOnHover !== 'false';
    const morphTargetHTML = iconElement.dataset.morphTarget;
    const primaryColor = iconElement.dataset.primaryColor;

    const svg = iconElement.querySelector('svg');
    if (!svg) return;

    const paths = Array.from(svg.querySelectorAll('path')) as SVGPathElement[];
    if (paths.length === 0) return;

    // Get computed colors from parent element
    const computedStyle = getComputedStyle(iconElement);
    const inheritedFill = computedStyle.fill || computedStyle.color || '#f5f5dc';
    const targetColor = primaryColor || computedStyle.getPropertyValue('--icon-primary-color') || inheritedFill;

    // Setup morph target
    let morphTargetPaths: SVGPathElement[] = [];
    if (morphTargetHTML) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = morphTargetHTML;
      const targetSvg = tempDiv.querySelector('svg');
      if (targetSvg) {
        morphTargetPaths = Array.from(targetSvg.querySelectorAll('path'));

        // Normalize point counts and smooth corners for smoother morphing
        morphTargetPaths = morphTargetPaths.map(targetPath => {
          const normalized = MorphSVGPlugin.convertToPath(targetPath)[0];
          // Apply corner smoothing (radius of 3 for subtle rounding)
          const smoothed = MorphSVGPlugin.pathFilter(normalized, 3);
          return (smoothed || normalized) as SVGPathElement;
        });
      }
    }

    // Normalize original paths for morphing
    paths.forEach(path => {
      if (!path._normalizedPath) {
        const normalized = MorphSVGPlugin.convertToPath(path)[0];
        // Apply corner smoothing (radius of 3 for subtle rounding)
        const smoothed = MorphSVGPlugin.pathFilter(normalized, 3);
        path._normalizedPath = smoothed ? smoothed.getAttribute('d') || '' : normalized.getAttribute('d') || '';
        path._originalPath = path.getAttribute('d') || '';
      }
    });

    // Setup initial state with GSAP
    paths.forEach(path => {
      gsap.set(path, {
        fill: inheritedFill,
        stroke: 'none'
      });
    });

    let timeline: gsap.core.Timeline | null = null;
    let morphed = false;

    // Animation trigger
    const triggerAnimation = () => {
      if (timeline) timeline.kill();
      timeline = gsap.timeline();

      paths.forEach((path, index) => {
        const duration = 0.4;
        const targetPath = morphTargetPaths[index];

        if (!targetPath) return;

        if (!morphed) {
          // Forward morph with color transition
          timeline!
            .to(path, {
              morphSVG: {
                shape: targetPath,
                type: 'rotational',  // Use rotational for more natural morphs
                shapeIndex: 5  // Forward direction alignment
              },
              fill: targetColor,
              duration: duration,
              ease: 'cubic-bezier(0.34, 1.56, 0.64, 1)'  // Nice bounce-out bezier
            }, 0);
        } else {
          // Reverse morph with color transition back
          timeline!
            .to(path, {
              morphSVG: {
                shape: path._originalPath || path,
                type: 'rotational',
                shapeIndex: -5  // Negative index counts from end
              },
              fill: inheritedFill,
              duration: duration,
              ease: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
            }, 0);
        }

        if (!path._originalPath) {
          path._originalPath = path.getAttribute('d') || '';
        }
      });

      morphed = !morphed;
    };

    if (animateOnHover) {
      const triggerElement = iconElement.closest('button, a') || iconElement;

      let clicked = false;

      const onEnter = () => {
        if (!clicked && !morphed) triggerAnimation();
      };
      const onLeave = () => {
        if (!clicked && morphed) triggerAnimation();
      };
      const onClick = (e: Event) => {
        e.preventDefault();
        clicked = !clicked;
        if (clicked && !morphed) {
          triggerAnimation();
        } else if (!clicked && morphed) {
          triggerAnimation();
        }
      };

      triggerElement.addEventListener('mouseenter', onEnter);
      triggerElement.addEventListener('mouseleave', onLeave);
      triggerElement.addEventListener('click', onClick);
    } else {
      (iconElement as any).triggerAnimation = triggerAnimation;
    }
  }

  // Initialize all morph icons
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.morph-svg-icon').forEach(icon => {
      initMorphIcon(icon as HTMLElement);
    });
  });

  declare global {
    interface SVGPathElement {
      _normalizedPath?: string;
      _originalPath?: string;
    }
  }
</script>
